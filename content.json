{"posts":[{"title":"Spring Security 基本配置","text":"1.新建项目首先新建一个 Spring Boot 项目，创建时引入 Spring Security 依赖和 web 依赖 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 项目创建成功后，我们添加一个测试的 HelloController，内容如下： 12345678@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;SECURITY&quot;; }} 接下来什么事情都不用做，我们直接来启动项目。 在项目启动过程中，我们会看到如下一行日志： 1Using generated security password: 30abfb1f-36e1-446a-a79b-f70024f589ab 这就是 Spring Security 为默认用户 user 生成的临时密码，是一个 UUID 字符串。 接下来我们去访问 http://localhost:8080/hello 接口，就可以看到自动重定向到登录页面了 在登录页面，默认的用户名就是 user，默认的登录密码则是项目启动时控制台打印出来的密码，输入用户名密码之后，就登录成功了，登录成功后，我们就可以访问到 /hello 接口了。 在 Spring Security 中，默认的登录页面和登录接口，都是 /login ，只不过一个是 get 请求（登录页面），另一个是 post 请求（登录接口）。 大家可以看到，非常方便，一个依赖就保护了所有接口。 有人说，你怎么知道知道生成的默认密码是一个 UUID 呢？ 这个其实很好判断。 和用户相关的自动化配置类在 UserDetailsServiceAutoConfiguration 里边，在该类的 getOrDeducePassword 方法中，我们看到如下一行日志： 123if (user.isPasswordGenerated()) { logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword()));} 毫无疑问，我们在控制台看到的日志就是从这里打印出来的。打印的条件是 isPasswordGenerated 方法返回 true，即密码是默认生成的。 进而我们发现，user.getPassword 出现在 SecurityProperties 中，在 SecurityProperties 中我们看到如下定义： 123456789/** * Default user name. */private String name = &quot;user&quot;;/** * Password for the default user name. */private String password = UUID.randomUUID().toString();private boolean passwordGenerated = true; 可以看到，默认的用户名就是 user，默认的密码则是 UUID，而默认情况下，passwordGenerated 也为 true。 2.用户配置默认的密码有一个问题就是每次重启项目都会变，这很不方便。 在正式介绍数据库连接之前，松哥先和大家介绍两种非主流的用户名/密码配置方案。 2.1 配置文件我们可以在 application.properties 中配置默认的用户名密码。 怎么配置呢？大家还记得上一小节我们说的 SecurityProperties，默认的用户就定义在它里边，是一个静态内部类，我们如果要定义自己的用户名密码，必然是要去覆盖默认配置，我们先来看下 SecurityProperties 的定义： 12@ConfigurationProperties(prefix = &quot;spring.security&quot;)public class SecurityProperties { 这就很清晰了，我们只需要以 spring.security.user 为前缀，去定义用户名密码即可： 123spring.security.user.name=userspring.security.user.password=123spring.security.user.roles=admin 这就是我们新定义的用户名密码。 在 properties 中定义的用户名密码最终是通过 set 方法注入到属性中去的，这里我们顺便来看下 SecurityProperties.User#setPassword 方法: 从这里我们可以看到，application.properties 中定义的密码在注入进来之后，还顺便设置了 passwordGenerated 属性为 false，这个属性设置为 false 之后，控制台就不会打印默认的密码了。 此时重启项目，就可以使用自己定义的用户名/密码登录了。 2.2 配置类除了上面的配置文件这种方式之外，我们也可以在配置类中配置用户名/密码。 在配置类中配置，我们就要指定 PasswordEncoder 了，这是一个非常关键的东西。 考虑到有的小伙伴对于 PasswordEncoder 还不太熟悉，因此，我这里先稍微给大家介绍一下 PasswordEncoder 到底是干嘛用的。要说 PasswordEncoder ，就得先说密码加密。 2.2.1 为什么要加密2011 年 12 月 21 日，有人在网络上公开了一个包含 600 万个 CSDN 用户资料的数据库，数据全部为明文储存，包含用户名、密码以及注册邮箱。事件发生后 CSDN 在微博、官方网站等渠道发出了声明，解释说此数据库系 2009 年备份所用，因不明原因泄露，已经向警方报案，后又在官网发出了公开道歉信。在接下来的十多天里，金山、网易、京东、当当、新浪等多家公司被卷入到这次事件中。整个事件中最触目惊心的莫过于 CSDN 把用户密码明文存储，由于很多用户是多个网站共用一个密码，因此一个网站密码泄露就会造成很大的安全隐患。由于有了这么多前车之鉴，我们现在做系统时，密码都要加密处理。 这次泄密，也留下了一些有趣的事情，特别是对于广大程序员设置密码这一项。人们从 CSDN 泄密的文件中，发现了一些好玩的密码，例如如下这些： ppnn13%dkstFeb.1st 这段密码的中文解析是：娉娉袅袅十三余，豆蔻梢头二月初。 csbt34.ydhl12s 这段密码的中文解析是：池上碧苔三四点，叶底黄鹂一两声 … 等等不一而足，你会发现很多程序员的人文素养还是非常高的，让人啧啧称奇。 2.2.2 加密方案密码加密我们一般会用到散列函数，又称散列算法、哈希函数，这是一种从任何数据中创建数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，重新创建一个散列值。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有 MD5 消息摘要算法、安全散列算法（Secure Hash Algorithm）。 但是仅仅使用散列函数还不够，为了增加密码的安全性，一般在密码加密过程中还需要加盐，所谓的盐可以是一个随机数也可以是用户名，加盐之后，即使密码明文相同的用户生成的密码密文也不相同，这可以极大的提高密码的安全性。但是传统的加盐方式需要在数据库中有专门的字段来记录盐值，这个字段可能是用户名字段（因为用户名唯一），也可能是一个专门记录盐值的字段，这样的配置比较繁琐。 Spring Security 提供了多种密码加密方案，官方推荐使用 BCryptPasswordEncoder，BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。 不同于 Shiro 中需要自己处理密码加盐，在 Spring Security 中，BCryptPasswordEncoder 就自带了盐，处理起来非常方便。 而 BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类。 2.2.3 PasswordEncoderPasswordEncoder 这个接口中就定义了三个方法： 1234567public interface PasswordEncoder { String encode(CharSequence rawPassword); boolean matches(CharSequence rawPassword, String encodedPassword); default boolean upgradeEncoding(String encodedPassword) { return false; }} encode 方法用来对明文密码进行加密，返回加密之后的密文。 matches 方法是一个密码校对方法，在用户登录的时候，将用户传来的明文密码和数据库中保存的密文密码作为参数，传入到这个方法中去，根据返回的 Boolean 值判断用户密码是否输入正确。 upgradeEncoding 是否还要进行再次加密，这个一般来说就不用了。 2.2.4 配置预备知识讲完后，接下来我们来看具体如何配置： @EnableWebSecurity:才可生效 @Configurable 不生效 12345678910111213@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication().withUser(&quot;admin&quot;).password(passwordEncoder().encode(&quot;123&quot;)).roles(&quot;admin&quot;).authorities(&quot;index&quot;,&quot;detail&quot;); auth.inMemoryAuthentication().withUser(&quot;user&quot;).password(passwordEncoder().encode(&quot;123&quot;)).roles(&quot;user&quot;).authorities(&quot;index&quot;); }} 首先我们自定义 SecurityConfig 继承自 WebSecurityConfigurerAdapter，重写里边的 configure 方法。 首先我们提供了一个 PasswordEncoder 的实例，因为目前的案例还比较简单，因此我暂时先不给密码进行加密，所以返回 NoOpPasswordEncoder 的实例即可。 configure 方法中，我们通过 inMemoryAuthentication 来开启在内存中定义用户，withUser 中是用户名，password 中则是用户密码，roles 中是用户角色。 如果需要配置多个用户，用 and 相连。 为什么用 and 相连呢？ 在没有 Spring Boot 的时候，我们都是 SSM 中使用 Spring Security，这种时候都是在 XML 文件中配置 Spring Security，既然是 XML 文件，标签就有开始有结束，现在的 and 符号相当于就是 XML 标签的结束符，表示结束当前标签，这是个时候上下文会回到 inMemoryAuthentication 方法中，然后开启新用户的配置。 配置完成后，再次启动项目，Java 代码中的配置会覆盖掉 XML 文件中的配置，此时再去访问 /hello 接口，就会发现只有 Java 代码中的用户名/密码才能访问成功。 3.HttpSecurity 配置12345678910111213141516171819@Overrideprotected void configure(HttpSecurity http) throws Exception { // 请求规则 http.authorizeRequests() .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;) .antMatchers(&quot;/user/**&quot;).hasAnyRole(&quot;user&quot;,&quot;admin&quot;) // 所有请求都进行认证 .anyRequest().authenticated() .and() // 开启表单登陆 .formLogin() // 用户登录 URL .loginProcessingUrl(&quot;/doLogin&quot;) // 登录请求都放行 .permitAll() .and() //关闭 CSRF 攻击 .csrf().disable();} 创建两个用户请求接口 123456789@GetMapping(&quot;/admin/hello&quot;)String helloAdmin(){ return &quot;hello admin&quot;;}@GetMapping(&quot;/user/hello&quot;)String userAdmin(){ return &quot;hello user&quot;;} 通过 postman 进行访问的时候，访问 /admin/user的时候，会跳转到login页面让你去登录，此时发送 /doLogin【上面配置的登录请求URL】拼接?username=admin&amp;password=123就会重定向到 /admin/user，此时已经成功登录，security就会放行请求。 4.表单登陆详细配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Overrideprotected void configure(HttpSecurity http) throws Exception { // 请求规则 http.authorizeRequests() .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;) .antMatchers(&quot;/user/**&quot;).hasAnyRole(&quot;user&quot;,&quot;admin&quot;) // 所有请求都进行认证 .anyRequest().authenticated() .and() // 开启表单登陆 .formLogin() // 用户登录请求 URL .loginProcessingUrl(&quot;/doLogin&quot;) // 登录页面 URL .loginPage(&quot;/login&quot;) // 自定义用户名参数 .usernameParameter(&quot;uname&quot;) // 自定义密码参数 .passwordParameter(&quot;passwd&quot;) // 登陆成功跳转的请求 //.successForwardUrl(&quot;/success/toPage&quot;) // 登陆成功处理器[前后端分离] .successHandler((req,resp,auth)-&gt;{ resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter writer = resp.getWriter(); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;status&quot;,200); map.put(&quot;message&quot;,auth.getPrincipal()); writer.write(new ObjectMapper().writeValueAsString(map)); writer.flush(); writer.close(); }) // 登录失败页面跳转页面 //.failureForwardUrl(&quot;/fail/toPage&quot;) // 登陆失败处理器[前后端分离] .failureHandler((req,resp,e)-&gt;{ resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter writer = resp.getWriter(); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;status&quot;,401); if(e instanceof LockedException){ map.put(&quot;message&quot;,&quot;账户被锁定&quot;); }else if(e instanceof BadCredentialsException){ map.put(&quot;message&quot;,&quot;用户名或密码输入错误&quot;); }else if(e instanceof DisabledException){ map.put(&quot;message&quot;,&quot;账户被禁用&quot;); }else if(e instanceof AccountExpiredException){ map.put(&quot;message&quot;,&quot;账户过期&quot;); }else if(e instanceof CredentialsExpiredException){ map.put(&quot;message&quot;,&quot;密码过期&quot;); }else { map.put(&quot;message&quot;,&quot;登录失败&quot;); } writer.write(new ObjectMapper().writeValueAsString(map)); writer.flush(); writer.close(); }) // 登录请求都放行 .permitAll() .and() //关闭 CSRF 攻击 .csrf().disable();} 自定义登录页面的接口 1234@GetMapping(&quot;/login&quot;)String userLogin(){ return &quot;请登录&quot;;} postman 发送请求 http://localhost:8080/admin/hello 页面会返回 请登录,这是因为自定义了前往登录页的请求/login 发送请求 http://localhost:8080/doLogin?uname=admin&amp;passwd=123 页面返回 JSON 数据 12345678910111213141516{ &quot;message&quot;: { &quot;password&quot;: null, &quot;username&quot;: &quot;admin&quot;, &quot;authorities&quot;: [ { &quot;authority&quot;: &quot;ROLE_admin&quot; } ], &quot;accountNonExpired&quot;: true, &quot;accountNonLocked&quot;: true, &quot;credentialsNonExpired&quot;: true, &quot;enabled&quot;: true }, &quot;status&quot;: 200} 再次访问http://localhost:8080/admin/hello 1hello admin 4.1 登陆成功回调在 Spring Security 中，和登录成功重定向 URL 相关的方法有两个： defaultSuccessUrl successForwardUrl 这两个咋看没什么区别，实际上内藏乾坤。 首先我们在配置的时候，defaultSuccessUrl 和 successForwardUrl 只需要配置一个即可，具体配置哪个，则要看你的需求，两个的区别如下： defaultSuccessUrl 有一个重载的方法，我们先说一个参数的 defaultSuccessUrl 方法。如果我们在 defaultSuccessUrl 中指定登录成功的跳转页面为 /index，此时分两种情况，如果你是直接在浏览器中输入的登录地址，登录成功后，就直接跳转到 /index，如果你是在浏览器中输入了其他地址，例如 http://localhost:8080/hello，结果因为没有登录，又重定向到登录页面，此时登录成功后，就不会来到 /index ，而是来到 /hello 页面。 defaultSuccessUrl 还有一个重载的方法，第二个参数如果不设置默认为 false，也就是我们上面的的情况，如果手动设置第二个参数为 true，则 defaultSuccessUrl 的效果和 successForwardUrl 一致。 successForwardUrl 表示不管你是从哪里来的，登录后一律跳转到 successForwardUrl 指定的地址。例如 successForwardUrl 指定的地址为 /index ，你在浏览器地址栏输入 http://localhost:8080/hello，结果因为没有登录，重定向到登录页面，当你登录成功之后，就会服务端跳转到 /index 页面；或者你直接就在浏览器输入了登录页面地址，登录成功后也是来到 /index。 12345678910.and().formLogin().loginPage(&quot;/login.html&quot;).loginProcessingUrl(&quot;/doLogin&quot;).usernameParameter(&quot;name&quot;).passwordParameter(&quot;passwd&quot;).defaultSuccessUrl(&quot;/index&quot;).successForwardUrl(&quot;/index&quot;).permitAll().and() 「注意：实际操作中，defaultSuccessUrl 和 successForwardUrl 只需要配置一个即可。」 4.2 登录失败回调与登录成功相似，登录失败也是有两个方法： failureForwardUrl failureUrl 「这两个方法在设置的时候也是设置一个即可」。failureForwardUrl 是登录失败之后会发生服务端跳转，failureUrl 则在登录失败之后，会发生重定向。 4.3 注销登录注销登录的默认接口是 /logout，我们也可以配置。 12345678910.and().logout().logoutUrl(&quot;/logout&quot;).logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;,&quot;POST&quot;)).logoutSuccessUrl(&quot;/index&quot;).deleteCookies().clearAuthentication(true).invalidateHttpSession(true).permitAll().and() 注销登录的配置我来说一下： 默认注销的 URL 是 /logout，是一个 GET 请求，我们可以通过 logoutUrl 方法来修改默认的注销 URL。 logoutRequestMatcher 方法不仅可以修改注销 URL，还可以修改请求方式，实际项目中，这个方法和 logoutUrl 任意设置一个即可。 logoutSuccessUrl 表示注销成功后要跳转的页面。 deleteCookies 用来清除 cookie。 clearAuthentication 和 invalidateHttpSession 分别表示清除认证信息和使 HttpSession 失效，默认可以不用配置，默认就会清除。 4.4 前后端分离登录无状态登录什么是有状态有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下： 服务端保存大量数据，增加服务端压力 服务端保存用户状态，不支持集群化部署 什么是无状态微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 那么这种无状态性有哪些好处呢？ 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署） 减小服务端存储压力 如何实现无状态无状态登录的流程： 首先客户端发送账户名/密码到服务端进行认证 认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端 以后客户端每次发送请求，都需要携带认证的 token 服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息 各自优缺点使用 session 最大的优点在于方便。你不用做过多的处理，一切都是默认的即可。 但是使用 session 有另外一个致命的问题就是如果你的前端是 Android、iOS、小程序等，这些 App 天然的就没有 cookie，如果非要用 session，就需要这些工程师在各自的设备上做适配，一般是模拟 cookie，从这个角度来说，在移动 App 遍地开花的今天，我们单纯的依赖 session 来做安全管理，似乎也不是特别理想。 这个时候 JWT 这样的无状态登录就展示出自己的优势了，这些登录方式所依赖的 token 你可以通过普通参数传递，也可以通过请求头传递，怎么样都行，具有很强的灵活性。 不过话说回来，如果你的前后端分离只是网页+服务端，其实没必要上无状态登录，基于 session 来做就可以了，省事又方便。 登录交互前后端分离的数据交互在前后端分离这样的开发架构下，前后端的交互都是通过 JSON 来进行，无论登录成功还是失败，都不会有什么服务端跳转或者客户端跳转之类。 登录成功了，服务端就返回一段登录成功的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，就和后端没有关系了。 登录失败了，服务端就返回一段登录失败的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，也和后端没有关系了。 首先把这样的思路确定了，基于这样的思路，我们来看一下登录配置。 登录成功之前我们配置登录成功的处理是通过如下两个方法来配置的： defaultSuccessUrl successForwardUrl 这两个都是配置跳转地址的，适用于前后端不分的开发。除了这两个方法之外，还有一个必杀技，那就是 successHandler。 successHandler 的功能十分强大，甚至已经囊括了 defaultSuccessUrl 和 successForwardUrl 的功能。我们来看一下： 12345678.successHandler((req, resp, authentication) -&gt; { Object principal = authentication.getPrincipal(); resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(principal)); out.flush(); out.close();}) successHandler 方法的参数是一个 AuthenticationSuccessHandler 对象，这个对象中我们要实现的方法是 onAuthenticationSuccess。 onAuthenticationSuccess 方法有三个参数，分别是： HttpServletRequest HttpServletResponse Authentication 有了前两个参数，我们就可以在这里随心所欲的返回数据了。利用 HttpServletRequest 我们可以做服务端跳转，利用 HttpServletResponse 我们可以做客户端跳转，当然，也可以返回 JSON 数据。 第三个 Authentication 参数则保存了我们刚刚登录成功的用户信息。 配置完成后，我们再去登录，就可以看到登录成功的用户信息通过 JSON 返回到前端了，如下： 12345678910111213{ &quot;password&quot;: null, &quot;username&quot;: &quot;admin&quot;, &quot;authorities&quot;: [ { &quot;authority&quot;: &quot;ROLE_admin&quot; } ], &quot;accountNonExpired&quot;: true, &quot;accountNonLocked&quot;: true, &quot;credentialsNonExpired&quot;: true, &quot;enabled&quot;: true} 登录失败登录失败也有一个类似的回调，如下： 1234567.failureHandler((req, resp, e) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(e.getMessage()); out.flush(); out.close();}) 失败的回调也是三个参数，前两个就不用说了，第三个是一个 Exception，对于登录失败，会有不同的原因，Exception 中则保存了登录失败的原因，我们可以将之通过 JSON 返回到前端。 当然大家也看到，在微人事中，我还挨个去识别了一下异常的类型，根据不同的异常类型，我们可以给用户一个更加明确的提示： 1234567891011121314151617resp.setContentType(&quot;application/json;charset=utf-8&quot;);PrintWriter out = resp.getWriter();RespBean respBean = RespBean.error(e.getMessage());if (e instanceof LockedException) { respBean.setMsg(&quot;账户被锁定，请联系管理员!&quot;);} elseif (e instanceof CredentialsExpiredException) { respBean.setMsg(&quot;密码过期，请联系管理员!&quot;);} elseif (e instanceof AccountExpiredException) { respBean.setMsg(&quot;账户过期，请联系管理员!&quot;);} elseif (e instanceof DisabledException) { respBean.setMsg(&quot;账户被禁用，请联系管理员!&quot;);} elseif (e instanceof BadCredentialsException) { respBean.setMsg(&quot;用户名或者密码输入错误，请重新输入!&quot;);}out.write(new ObjectMapper().writeValueAsString(respBean));out.flush();out.close(); 这里有一个需要注意的点。 我们知道，当用户登录时，用户名或者密码输入错误，我们一般只给一个模糊的提示，即「用户名或者密码输入错误，请重新输入」，而不会给一个明确的诸如“用户名输入错误”或“密码输入错误”这样精确的提示，但是对于很多不懂行的新手小伙伴，他可能就会给一个明确的错误提示，这会给系统带来风险。 但是使用了 Spring Security 这样的安全管理框架之后，即使你是一个新手，也不会犯这样的错误。 在 Spring Security 中，用户名查找失败对应的异常是： UsernameNotFoundException 密码匹配失败对应的异常是： BadCredentialsException 但是我们在登录失败的回调中，却总是看不到 UsernameNotFoundException 异常，无论用户名还是密码输入错误，抛出的异常都是 BadCredentialsException。 在登录中有一个关键的步骤，就是去加载用户数据，我们再来把这个方法拎出来看一下（部分）： 123456789101112131415161718public Authentication authenticate(Authentication authentication) throws AuthenticationException { try { user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); } catch (UsernameNotFoundException notFound) { logger.debug(&quot;User '&quot; + username + &quot;' not found&quot;); if (hideUserNotFoundExceptions) { thrownew BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } else { throw notFound; } }} 从这段代码中，我们看出，在查找用户时，如果抛出了 UsernameNotFoundException，这个异常会被捕获，捕获之后，如果 hideUserNotFoundExceptions 属性的值为 true，就抛出一个 BadCredentialsException。相当于将 UsernameNotFoundException 异常隐藏了，而默认情况下，hideUserNotFoundExceptions 的值就为 true。 看到这里大家就明白了为什么无论用户还是密码写错，你收到的都是 BadCredentialsException 异常。 一般来说这个配置是不需要修改的，如果你一定要区别出来 UsernameNotFoundException 和 BadCredentialsException，我这里给大家提供三种思路： 自己定义 DaoAuthenticationProvider 代替系统默认的，在定义时将 hideUserNotFoundExceptions 属性设置为 false。 当用户名查找失败时，不抛出 UsernameNotFoundException 异常，而是抛出一个自定义异常，这样自定义异常就不会被隐藏，进而在登录失败的回调中根据自定义异常信息给前端用户一个提示。 当用户名查找失败时，直接抛出 BadCredentialsException，但是异常信息为 “用户名不存在”。 除非情况特殊，一般不用修改这一块的默认行为。 官方这样做的好处是什么呢？很明显可以强迫开发者给一个模糊的异常提示，这样即使是不懂行的新手，也不会将系统置于危险之中。 好了，这样配置完成后，无论是登录成功还是失败，后端都将只返回 JSON 给前端了。 未认证处理方案那未认证又怎么办呢？ 有人说，那还不简单，没有认证就访问数据，直接重定向到登录页面就行了，这没错，系统默认的行为也是这样。 但是在前后端分离中，这个逻辑明显是有问题的，如果用户没有登录就访问一个需要认证后才能访问的页面，这个时候，我们不应该让用户重定向到登录页面，而是给用户一个尚未登录的提示，前端收到提示之后，再自行决定页面跳转。 要解决这个问题，就涉及到 Spring Security 中的一个接口 AuthenticationEntryPoint ，该接口有一个实现类：LoginUrlAuthenticationEntryPoint ，该类中有一个方法 commence，如下： 1234567891011121314151617181920212223242526/** * Performs the redirect (or forward) to the login form URL. */public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) { String redirectUrl = null; if (useForward) { if (forceHttps &amp;&amp; &quot;http&quot;.equals(request.getScheme())) { redirectUrl = buildHttpsRedirectUrlForRequest(request); } if (redirectUrl == null) { String loginForm = determineUrlToUseForThisRequest(request, response, authException); if (logger.isDebugEnabled()) { logger.debug(&quot;Server side forward to: &quot; + loginForm); } RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm); dispatcher.forward(request, response); return; } } else { redirectUrl = buildRedirectUrlToLoginPage(request, response, authException); } redirectStrategy.sendRedirect(request, response, redirectUrl);} 首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。 那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下： 123456789.csrf().disable().exceptionHandling().authenticationEntryPoint((req, resp, authException) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;尚未登录，请先登录&quot;); out.flush(); out.close(); }); 在 Spring Security 的配置中加上自定义的 AuthenticationEntryPoint 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。 注销登录最后我们再来看看注销登录的处理方案。 注销登录我们前面说过，按照前面的配置，注销登录之后，系统自动跳转到登录页面，这也是不合适的，如果是前后端分离项目，注销登录成功后返回 JSON 即可，配置如下： 123456789101112.and().logout().logoutUrl(&quot;/logout&quot;).logoutSuccessHandler((req, resp, authentication) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;注销成功&quot;); out.flush(); out.close();}).permitAll().and() 这样，注销成功之后，前端收到的也是 JSON 了： 5.多个 HttpSecurity12345678910111213141516171819202122232425262728293031323334353637383940414243444546@EnableWebSecuritypublic class MultiHttpSecurityConfig { @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication().withUser(&quot;admin&quot;).password(passwordEncoder().encode(&quot;123&quot;)).roles(&quot;admin&quot;); auth.inMemoryAuthentication().withUser(&quot;user&quot;).password(passwordEncoder().encode(&quot;123&quot;)).roles(&quot;user&quot;); } @EnableWebSecurity @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.antMatcher(&quot;/admin/**&quot;) .authorizeRequests() .anyRequest().hasAnyRole(&quot;admin&quot;); } } @EnableWebSecurity @Order(2) public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest() .authenticated() .and() .formLogin() .loginProcessingUrl(&quot;/doLogin&quot;) .permitAll() .and() .csrf().disable(); } }} 用户发送请求，会先去 AdminSecurityConfig匹配，在这个类只是拦截 /admin/**的请求，如果匹配不到就会去OtherSecurityConfig类中进行配置，在这个类中会拦截所有的请求。 6.方法级别的安全在配置类上方添加注解 @EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true) 123@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter { 创建 service 方法 123456789101112131415161718192021@Servicepublic class MethodService { @PreAuthorize(&quot;hasRole('admin')&quot;) public String admin(){ return &quot;method admin&quot;; } @Secured(&quot;ROLE_user&quot;) public String user(){ return &quot;method user&quot;; } @PreAuthorize(&quot;hasAnyRole('admin','user')&quot;) public String hello(){ return &quot;method hello&quot;; }}","link":"/2022/08/23/01-security%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"},{"title":"Spring Security 基于数据库 &amp; 角色继承","text":"授权所谓的授权，就是用户如果要访问某一个资源，我们要去检查用户是否具备这样的权限，如果具备就允许访问，如果不具备，则不允许访问。 准备数据库脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*Navicat MySQL Data TransferSource Server : localhostSource Server Version : 50717Source Host : localhost:3306Source Database : securityTarget Server Type : MYSQLTarget Server Version : 50717File Encoding : 65001Date: 2018-07-28 15:26:51*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for role-- ----------------------------DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `nameZh` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES ('1', 'dba', '数据库管理员');INSERT INTO `role` VALUES ('2', 'admin', '系统管理员');INSERT INTO `role` VALUES ('3', 'user', '用户');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `enabled` tinyint(1) DEFAULT NULL, `locked` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES ('1', 'root', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('2', 'admin', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('3', 'sang', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `uid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_role-- ----------------------------INSERT INTO `user_role` VALUES ('1', '1', '1');INSERT INTO `user_role` VALUES ('2', '1', '2');INSERT INTO `user_role` VALUES ('3', '2', '2');INSERT INTO `user_role` VALUES ('4', '3', '3');SET FOREIGN_KEY_CHECKS=1; 实体类 User 类 实现 UserDetail 接口中的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Data@NoArgsConstructor@AllArgsConstructor@Accessors(chain = true)@ToString(callSuper = true)@TableName(value = &quot;user&quot;,resultMap = &quot;userWithRolesMap&quot;)public class User implements UserDetails { @TableId(type = IdType.AUTO) private Integer id; private String username; private String password; private Boolean enabled; private Boolean locked; private List&lt;Role&gt; roles; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); roles.forEach(r-&gt;{ authorities.add(new SimpleGrantedAuthority(&quot;ROLE_&quot;+r.getName())); }); return authorities; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return !locked; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return enabled; }} Role 类 1234567@Data@TableName(&quot;role&quot;)public class Role { private Integer id; private String name; private String nameZh;} UserService 类实现 UserDetailService 类 123456789101112131415161718192021222324@Servicepublic class UserServiceImpl implements UserService , UserDetailsService { @Autowired UserMapper userMapper; /** * 根据用户名查询用户 * @param username the username identifying the user whose data is required. * @return UserDetails * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User user = userMapper.selectOne( new LambdaQueryWrapper&lt;User&gt;().eq(User::getUsername, username) ); if(user==null){ throw new UsernameNotFoundException(&quot;用户不存在&quot;); } return user; }} UserMapper 接口 123@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; {} UserMapper.xml 12345678910&lt;mapper namespace=&quot;com.wenx.security.security.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;userWithRolesMap&quot; type=&quot;com.wenx.security.security.bean.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;enabled&quot; property=&quot;enabled&quot;/&gt; &lt;result column=&quot;locked&quot; property=&quot;locked&quot;/&gt; &lt;collection property=&quot;roles&quot; column=&quot;id&quot; select=&quot;com.wenx.security.security.mapper.RoleMapper.selectRolesByUid&quot;/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; RoleMapper.xml 12345&lt;mapper namespace=&quot;com.wenx.security.security.mapper.RoleMapper&quot;&gt; &lt;select id=&quot;selectRolesByUid&quot; resultType=&quot;com.wenx.security.security.bean.Role&quot;&gt; select r.* from role r,user u,user_role ur where u.id=ur.uid and r.id=ur.rid and u.id = #{uid} &lt;/select&gt;&lt;/mapper&gt; 配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.wenx.security.security.config;import com.wenx.security.security.service.UserService;import com.wenx.security.security.service.impl.UserServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import javax.annotation.Resource;@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Resource UserServiceImpl userService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&quot;/dba/**&quot;).hasRole(&quot;dba&quot;) .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;) .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;) .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); }} 准备接口1234567891011121314151617181920@GetMapping(&quot;/hello&quot;)String hello(){ return &quot;hello&quot;;}@GetMapping(&quot;/dba/hello&quot;)String dbaHello(){ return &quot;DBA hello&quot;;}@GetMapping(&quot;/admin/hello&quot;)String adminHello(){ return &quot;admin hello&quot;;}@GetMapping(&quot;/user/hello&quot;)String userHello(){ return &quot;user hello&quot;;} 当我们使用 root 用户进行登录，/dba/hello /admin/hello是可以进行访问的 /user/hello没有权限访问 角色继承角色继承实际上是一个很常见的需求，因为大部分公司治理可能都是金字塔形的，上司可能具备下属的部分甚至所有权限，这一现实场景，反映到我们的代码中，就是角色继承了。 Spring Security 中为开发者提供了相关的角色继承解决方案，但是这一解决方案在最近的 Spring Security 版本变迁中，使用方法有所变化。 pringSecurity 在角色继承上有两种不同的写法，在 Spring Boot2.0.8（对应 Spring Security 也是 5.0.11）上面是一种写法，从 Spring Boot2.1.0（对应 Spring Security5.1.1）又是另外一种写法 以前的写法这里说的以前写法，就是指 SpringBoot2.0.8（含）之前的写法，在之前的写法中，角色继承只需要开发者提供一个 RoleHierarchy 接口的实例即可，例如下面这样： 1234567@BeanRoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = &quot;ROLE_dba &gt; ROLE_admin ROLE_admin &gt; ROLE_user&quot;; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy;} 在这里我们提供了一个 RoleHierarchy 接口的实例，使用字符串来描述了角色之间的继承关系， ROLE_dba 具备 ROLE_admin 的所有权限，而 ROLE_admin 则具备 ROLE_user 的所有权限，继承与继承之间用一个空格隔开。提供了这个 Bean 之后，以后所有具备 ROLE_user 角色才能访问的资源， ROLE_dba 和 ROLE_admin 也都能访问，具备 ROLE_amdin 角色才能访问的资源， ROLE_dba 也能访问。 现在的写法但是上面这种写法仅限于 Spring Boot2.0.8（含）之前的版本，在之后的版本中，这种写法则不被支持，新版的写法是下面这样： 1234567@BeanRoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = &quot;ROLE_dba &gt; ROLE_admin \\n ROLE_admin &gt; ROLE_user&quot;; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy;} 变化主要就是分隔符，将原来用空格隔开的地方，现在用换行符了。这里表达式的含义依然和上面一样，不再赘述。 上面两种不同写法都是配置角色的继承关系，配置完成后，接下来指定角色和资源的对应关系即可，如下： 123456789101112131415@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().antMatchers(&quot;/admin/**&quot;) .hasRole(&quot;admin&quot;) .antMatchers(&quot;/db/**&quot;) .hasRole(&quot;dba&quot;) .antMatchers(&quot;/user/**&quot;) .hasRole(&quot;user&quot;) .and() .formLogin() .loginProcessingUrl(&quot;/doLogin&quot;) .permitAll() .and() .csrf().disable();} 这个表示 /db/** 格式的路径需要具备 dba 角色才能访问， /admin/** 格式的路径则需要具备 admin 角色才能访问， /user/** 格式的路径，则需要具备 user 角色才能访问，此时提供相关接口，会发现，dba 除了访问 /db/** ，也能访问 /admin/** 和 /user/** ，admin 角色除了访问 /admin/** ，也能访问 /user/** ，user 角色则只能访问 /user/** 。 源码分析这样两种不同的写法，其实也对应了两种不同的解析策略，角色继承关系的解析在 RoleHierarchyImpl 类的 buildRolesReachableInOneStepMap 方法中，Spring Boot2.0.8（含）之前该方法的源码如下： 12345678910111213141516171819202122232425private void buildRolesReachableInOneStepMap() { Pattern pattern = Pattern.compile(&quot;(\\\\s*([^\\\\s&gt;]+)\\\\s*&gt;\\\\s*([^\\\\s&gt;]+))&quot;); Matcher roleHierarchyMatcher = pattern .matcher(this.roleHierarchyStringRepresentation); this.rolesReachableInOneStepMap = new HashMap&lt;GrantedAuthority, Set&lt;GrantedAuthority&gt;&gt;(); while (roleHierarchyMatcher.find()) { GrantedAuthority higherRole = new SimpleGrantedAuthority( roleHierarchyMatcher.group(2)); GrantedAuthority lowerRole = new SimpleGrantedAuthority( roleHierarchyMatcher.group(3)); Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet; if (!this.rolesReachableInOneStepMap.containsKey(higherRole)) { rolesReachableInOneStepSet = new HashSet&lt;&gt;(); this.rolesReachableInOneStepMap.put(higherRole, rolesReachableInOneStepSet); } else { rolesReachableInOneStepSet = this.rolesReachableInOneStepMap .get(higherRole); } addReachableRoles(rolesReachableInOneStepSet, lowerRole); logger.debug(&quot;buildRolesReachableInOneStepMap() - From role &quot; + higherRole + &quot; one can reach role &quot; + lowerRole + &quot; in one step.&quot;); }} 从这段源码中我们可以看到，角色的继承关系是通过正则表达式进行解析，通过空格进行切分，然后构建相应的 map 出来。 Spring Boot2.1.0（含）之后该方法的源码如下： 12345678910111213141516171819202122232425262728private void buildRolesReachableInOneStepMap() { this.rolesReachableInOneStepMap = new HashMap&lt;GrantedAuthority, Set&lt;GrantedAuthority&gt;&gt;(); try (BufferedReader bufferedReader = new BufferedReader( new StringReader(this.roleHierarchyStringRepresentation))) { for (String readLine; (readLine = bufferedReader.readLine()) != null;) { String[] roles = readLine.split(&quot; &gt; &quot;); for (int i = 1; i &lt; roles.length; i++) { GrantedAuthority higherRole = new SimpleGrantedAuthority( roles[i - 1].replaceAll(&quot;^\\\\s+|\\\\s+$&quot;, &quot;&quot;)); GrantedAuthority lowerRole = new SimpleGrantedAuthority(roles[i].replaceAll(&quot;^\\\\s+|\\\\s+$ Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet; if (!this.rolesReachableInOneStepMap.containsKey(higherRole)) { rolesReachableInOneStepSet = new HashSet&lt;GrantedAuthority&gt;(); this.rolesReachableInOneStepMap.put(higherRole, rolesReachableInOneStepSet); } else { rolesReachableInOneStepSet = this.rolesReachableInOneStepMap.get(higherRole); } addReachableRoles(rolesReachableInOneStepSet, lowerRole); if (logger.isDebugEnabled()) { logger.debug(&quot;buildRolesReachableInOneStepMap() - From role &quot; + higherRole + &quot; one can reach role &quot; + lowerRole + &quot; in one step.&quot;); } } } } catch (IOException e) { throw new IllegalStateException(e); }} 从这里我们可以看到，这里并没有一上来就是用正则表达式，而是先将角色继承字符串转为一个 BufferedReader ，然后一行一行的读出来，再进行解析，最后再构建相应的 map。从这里我们可以看出为什么前后版本对此有不同的写法。","link":"/2022/08/24/02-security%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"Spring Security OAuth2 介绍","text":"1. 为什么我们需要 OAuth2关于我们为什么需要 OAuth2 的问题，网上的文章很多，我们常见的第三方登录就是一个 OAuth2 的典型应用，阮一峰大佬之前有一篇文章非常形象的解释了这个问题，内容如下（原文地址：https://www.ruanyifeng.com/blog/2019/04/oauth_design.html）： 1.1 快递员问题我住在一个大型的居民小区。 小区有门禁系统。 进入的时候需要输入密码。 我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区。 如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。 有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？ 1.2 授权机制的设计于是，我设计了一套授权机制。 第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。 第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。 我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。 第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。 第四步，快递员向门禁系统输入令牌，进入小区。 有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。 1.3 互联网场景我们把上面的例子搬到互联网，就是 OAuth 的设计了。 首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。 其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。 最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 1.4 令牌与密码令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。 （1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 （2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。 （3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。 上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth2.0 的优点。 注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。 OAuth2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。 这段看完，相信大家已经大概明白 OAuth2 的作用了。 2. 什么是 OAuth2OAuth 是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密资源（如头像、照片、视频等），而在这个过程中无需将用户名和密码提供给第三方应用。实现这一功能是通过提供一个令牌（token），而不是用户名和密码来访问他们存放在特定服务提供者的数据。采用令牌（token）的方式可以让用户灵活的对第三方应用授权或者收回权限。 OAuth2 是 OAuth 协议的下一版本，但不向下兼容 OAuth 1.0。传统的 Web 开发登录认证一般都是基于 session 的，但是在前后端分离的架构中继续使用 session 就会有许多不便，因为移动端（Android、iOS、微信小程序等）要么不支持 cookie（微信小程序），要么使用非常不便，对于这些问题，使用 OAuth2 认证都能解决。 对于大家而言，我们在互联网应用中最常见的 OAuth2 应该就是各种第三方登录了，例如 QQ 授权登录、微信授权登录、微博授权登录、GitHub 授权登录等等。 3. 四种模式OAuth2 协议一共支持 4 种不同的授权模式： 授权码模式：常见的第三方平台登录功能基本都是使用这种模式。 简化模式：简化模式是不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌（token），一般如果网站是纯静态页面则可以采用这种方式。 密码模式：密码模式是用户把用户名密码直接告诉客户端，客户端使用说这些信息向授权服务器申请令牌（token）。这需要用户对客户端高度信任，例如客户端应用和服务提供商就是同一家公司，我们自己做前后端分离登录就可以采用这种模式。 客户端模式：客户端模式是指客户端使用自己的名义而不是用户的名义向服务提供者申请授权，严格来说，客户端模式并不能算作 OAuth 协议要解决的问题的一种解决方案，但是，对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是非常方便的。 3.1 授权码模式授权码模式是最安全并且使用最广泛的一种模式 在授权码模式中，我们分授权服务器和资源服务器，授权服务器用来派发 Token，拿着 Token 则可以去资源服务器获取资源，这两个服务器可以分开，也可以合并。 首先，我会在我的网页上放一个超链接（我的网站相当于是第三方应用），用户 A （服务方的用户，例如微信用户）点击这个超链接就会去请求授权服务器（微信的授权服务器），用户点击的过程其实也就是我跟用户要授权的过程，这就是上图中的 1、2 步。 接下来的第三步，就是用户点击了超链接之后，像授权服务器发送请求，一般来说，我放在网页上的超链接可能有如下参数： 1https://wx.qq.com/oauth/authorize?response_type=code&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all 这里边有好几个参数，在后面的代码中我们都会用到，这里先和大家简单解释一下： response_type 表示授权类型，使用授权码模式的时候这里固定为 code，表示要求返回授权码（将来拿着这个授权码去获取 access_token）。 client_id 表示客户端 id，也就是我应用的 id。有的小伙伴对这个不好理解，我说一下，如果我想让我的 www.javaboy.org 接入微信登录功能，我肯定得去微信开放平台注册，去填入我自己应用的基本信息等等，弄完之后，微信会给我一个 APPID，也就是我这里的 client_id，所以，从这里可以看出，授权服务器在校验的时候，会做两件事：1.校验客户端的身份；2.校验用户身份。 redirect_uri 表示用户登录在成功/失败后，跳转的地址（成功登录微信后，跳转到 www.javaboy.org 中的哪个页面），跳转的时候，还会携带上一个授权码参数。 scope 表示授权范围，即 www.javaboy.org 这个网站拿着用户的 token 都能干啥（一般来说就是获取用户非敏感的基本信息）。 接下来第四步，我们的网站，拿着第三步获取到的 code 以及自己的 client_id 和 client_secret 以及其他一些信息去授权服务器请求令牌，微信的授权服务器在校验过这些数据之后，就会发送一个令牌回来。这个过程一般是在后端完成的，而不是利用 js 去完成。 接下来拿着这个 token，我们就可以去请求用户信息了。 一般情况下我们认为授权码模式是四种模式中最安全的一种模式，因为这种模式我们的 access_token 不用经过浏览器或者移动端 App，是直接从我们的后台发送到授权服务器上，这样就很大程度减少了 access_token 泄漏的风险。 OK，这是我们介绍的授权码模式。 3.2 简化模式简化模式是怎么一回事呢？ 这个流程是这样： 在网站上有一个微信登录的超链接，这个超链接类似下面这样： 1https://wx.qq.com/oauth/authorize?response_type=token&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all 这里的参数和前面授权码模式的基本相同，只有 response_type 的值不一样，这里是 token，表示要求授权服务器直接返回 access_token。 用户点击我这个超链接之后，就会跳转到微信登录页面，然后用户进行登录。 用户登录成功后，微信会自动重定向到 redirect_uri 参数指定的跳转网址，同时携带上 access_token，这样用户在前端就获取到 access_token 了。 简化模式的弊端很明显，因为没有后端，所以非常不安全，除非你对安全性要求不高，否则不建议使用。 3.3 密码模式密码模式在 Spring Cloud 项目中有着非常广泛的应用。 密码模式有一个前提就是你高度信任第三方应用，举个不恰当的例子：如果我要在 网站上接入微信登录，我使用了密码模式，那你就要在网站去输入微信的用户名密码，这肯定是不靠谱的，所以密码模式需要你非常信任第三方应用。 微服务中有一个特殊的场景，就是服务之间的调用，用密码模式做鉴权是非常恰当不过的了。 密码式的流程比较简单： 首先会发送一个 post 请求，类似下面这样的： 1https://wx.qq.com/oauth/authorize?response_type=password&amp;client_id=javaboy&amp;username=江南一点雨&amp;password=123 这里的参数和前面授权码模式的略有差异，response_type 的值不一样，这里是 password，表示密码式，另外多了用户名/密码参数，没有重定向的 redirect_uri ，因为这里不需要重定向。 微信校验过用户名/密码之后，直接在 HTTP 响应中把 access_token 返回给客户端。 3.4 客户端模式有的应用可能没有前端页面，就是一个后台 这个步骤也很简单，就两步： 客户端发送一个请求到授权服务器，请求格式如下： 1GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;client_id=APPID&amp;client_secret=APPSECRET 这里有三个参数，含义如下： grant_type，获取access_token填写client_credential client_id 和 client_secret 用来确认客户端的身份 授权服务器通过验证后，会直接返回 access_token 给客户端。 大家发现，在这个过程中好像没有用户什么事了！是的，客户端模式给出的令牌，就是针对第三方应用的，而不是针对用户的。 在接入微信公众号后台的时候，有一个获取 Access_token 的步骤，其实就是这种模式。 可以看到，这其实就是客户端模式。","link":"/2022/08/24/04-OAuth2%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"title":"Spring Security 基于数据库 &amp; 动态配置权限","text":"[TOC] RBAC权限设计思想为了达成不同账号(员工，经理，BOSS)登录系统后能看到不同页面，执行不同的功能，RBAC(Role-Based-Access-Control)权限模型，就是根据角色的权限，分配可视页面。 三个关键点：用户:使用系统的人角色：使用系统的人是什么职位(员工，经理，BOSS)权限点：职位可以做的事情(左侧菜单栏中的功能模块——&gt;增删改查) 测试流程：①在员工管理页新增员工这是三要素中的用户②为新增的员工分配角色③在公司设置里为角色分配权限 💢系统中的权限不能随意添加，必须是以开发出来的权限（左侧菜单栏里可实现的页面）💢用户和角色之间是一对多的关系，一个人身兼数职。 数据库设计：本案例数据库设计共涉及五张表：user role user_role menu menu_role 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* Navicat Premium Data Transfer Source Server : 本地 Source Server Type : MySQL Source Server Version : 50734 Source Host : localhost:3306 Source Schema : security Target Server Type : MySQL Target Server Version : 50734 File Encoding : 65001 Date: 24/08/2022 15:36:45*/SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for menu-- ----------------------------DROP TABLE IF EXISTS `menu`;CREATE TABLE `menu` ( `id` int(8) NOT NULL AUTO_INCREMENT, `pattern` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of menu-- ------------------------------ ------------------------------ Table structure for menu_role-- ----------------------------DROP TABLE IF EXISTS `menu_role`;CREATE TABLE `menu_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `mid` int(11) NOT NULL, `rid` int(11) NOT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of menu_role-- ----------------------------INSERT INTO `menu_role` VALUES (1, 1, 1);INSERT INTO `menu_role` VALUES (2, 2, 2);INSERT INTO `menu_role` VALUES (3, 3, 3);-- ------------------------------ Table structure for role-- ----------------------------DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `nameZh` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES (1, 'ROLE_dba', '数据库管理员');INSERT INTO `role` VALUES (2, 'ROLE_admin', '系统管理员');INSERT INTO `role` VALUES (3, 'ROLE_user', '用户');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `enabled` tinyint(1) NULL DEFAULT NULL, `locked` tinyint(1) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (1, 'root', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', 1, 0);INSERT INTO `user` VALUES (2, 'admin', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', 1, 0);INSERT INTO `user` VALUES (3, 'sang', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', 1, 0);-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `uid` int(11) NULL DEFAULT NULL, `rid` int(11) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of user_role-- ----------------------------INSERT INTO `user_role` VALUES (1, 1, 1);INSERT INTO `user_role` VALUES (2, 1, 2);INSERT INTO `user_role` VALUES (3, 2, 2);INSERT INTO `user_role` VALUES (4, 3, 3);SET FOREIGN_KEY_CHECKS = 1; 项目创建代码修改相较于上一个项目添加了一个实体类相关代码 Menu.java 12345678910111213@Data@NoArgsConstructor@AllArgsConstructor@Accessors(chain = true)@ToString(callSuper = true)@TableName(value = &quot;menu&quot;,resultMap = &quot;menuWithRolesMap&quot;)public class Menu { @TableId(type = IdType.AUTO) private Integer id; private String pattern; private List&lt;Role&gt; roles;} MenuMapper 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.wenx.security.dynamic.mapper.MenuMapper&quot;&gt; &lt;resultMap id=&quot;menuWithRolesMap&quot; type=&quot;com.wenx.security.dynamic.bean.Menu&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;pattern&quot; property=&quot;pattern&quot;/&gt; &lt;collection property=&quot;roles&quot; column=&quot;id&quot; select=&quot;com.wenx.security.dynamic.mapper.RoleMapper.selectRolesByMid&quot;/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 修改RoleMapper.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.wenx.security.dynamic.mapper.RoleMapper&quot;&gt; &lt;select id=&quot;selectRolesByUid&quot; resultType=&quot;com.wenx.security.dynamic.bean.Role&quot;&gt; select r.* from role r,user u,user_role ur where u.id=ur.uid and r.id=ur.rid and u.id = #{uid} &lt;/select&gt; &lt;select id=&quot;selectRolesByMid&quot; resultType=&quot;com.wenx.security.dynamic.bean.Role&quot;&gt; select r.* from role r,menu m,menu_role mr where m.id=mr.mid and r.id=mr.rid and m.id = #{mid} &lt;/select&gt;&lt;/mapper&gt; 重写 FilterInvocationSecurityMetadataSourceMyFiletr.java 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author 温笙 */@Componentpublic class MyFilter implements FilterInvocationSecurityMetadataSource { // 路径规则匹配器 AntPathMatcher antPathMatcher = new AntPathMatcher(); @Autowired MenuMapper menuMapper; @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException { String requestUrl = ((FilterInvocation) object).getRequestUrl(); List&lt;Menu&gt; menus = menuMapper.selectList(null); for (Menu menu : menus) { if(antPathMatcher.match(menu.getPattern(),requestUrl)){ List&lt;Role&gt; roles = menu.getRoles(); String[] rolesStr = new String[roles.size()]; for (int i = 0; i &lt; roles.size(); i++) { rolesStr[i]=roles.get(i).getName(); } return SecurityConfig.createList(rolesStr); } } return SecurityConfig.createList(&quot;ROLE_login&quot;); } @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() { return null; } @Override public boolean supports(Class&lt;?&gt; clazz) { return false; }} 用户所有的请求都会进入getAttributes这个方法中，通过路径匹配器进行匹配，将对应的权限字符串进行返回，如果匹配不到就返回一个ROLE_login标志符，后续进行判断放行。 重写决策管理器AccessDecisionManager1234567891011121314151617181920212223242526272829303132333435@Componentpublic class MyAccessDecisionManager implements AccessDecisionManager { @Override public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException { for (ConfigAttribute attribute : configAttributes) { if(&quot;ROLE_login&quot;.equals(attribute.getAttribute())){ if(authentication instanceof AnonymousAuthenticationToken){ throw new AccessDeniedException(&quot;非法请求&quot;); }else{ return; } } Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities(); for (GrantedAuthority authority : authorities) { if(authority.getAuthority().equals(attribute.getAttribute())){ return; } } } throw new AccessDeniedException(&quot;非法请求&quot;); } @Override public boolean supports(ConfigAttribute attribute) { return true; } @Override public boolean supports(Class&lt;?&gt; clazz) { return true; }} 配置类12345678910111213141516171819202122232425262728293031323334353637383940@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Resource UserService userService; @Autowired MyFilter myFilter; @Autowired MyAccessDecisionManager myAccessDecisionManager; @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() { @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) { object.setAccessDecisionManager(myAccessDecisionManager); object.setSecurityMetadataSource(myFilter); return object; } }) .and() .formLogin() .permitAll() .and() .csrf().disable(); }} 源码分析首先在 Spring Security 中的权限控制有两种不同的方式： 通过 URL 请求地址进行控制。 通过方法进行控制。 如果通过 URL 请求地址进行控制，负责控制类配置的是 AbstractInterceptUrlConfigurer，我们来看下它的子类： 123# AbstractInterceptUrlConfigurer## UrlAuthorizationConfigurer## ExpressionUrlAuthorizationConfigurer 可以看到它有两个子类： ExpressionUrlAuthorizationConfigurer UrlAuthorizationConfigurer 两个都可以处理基于 URL 请求地址的权限控制。不同的是，第一个 ExpressionUrlAuthorizationConfigurer支持权限表达式，第二个不支持。 UrlAuthorizationConfigurer 不支持权限表达式，是因为它使用的投票器是 RoleVoter 和 AuthenticatedVoter，这两者可以用来处理角色或者权限，但是没法处理权限表达式。 上面说的都是默认行为，我们也可以通过修改配置，让 UrlAuthorizationConfigurer 支持权限表达式，不过一般来说没必要这样做，如果需要支持权限表达式，直接用 ExpressionUrlAuthorizationConfigurer 即可。 当我们调用如下这行代码时： 1http.authorizeRequests() 实际上就是通过 ExpressionUrlAuthorizationConfigurer 去配置基于 URL 请求地址的权限控制，所以它是支持权限表达式的。例如下面这段大家再熟悉不过的代码： 1234http.authorizeRequests() .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) .antMatchers(&quot;/user/**&quot;).access(&quot;hasRole('USER')&quot;) 在 ExpressionUrlAuthorizationConfigurer 中创建 SecurityMetadataSource 时，就会检查映射关系，如果 requestMap 为空就会抛出异常： 123456789101112@OverrideExpressionBasedFilterInvocationSecurityMetadataSource createMetadataSource( H http) { LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = REGISTRY .createRequestMap(); if (requestMap.isEmpty()) { throw new IllegalStateException( &quot;At least one mapping is required (i.e. authorizeRequests().anyRequest().authenticated())&quot;); } return new ExpressionBasedFilterInvocationSecurityMetadataSource(requestMap, getExpressionHandler(http));} UrlAuthorizationConfigurer 中也有 createMetadataSource 方法，但是却是另外一套实现方案： 12345@OverrideFilterInvocationSecurityMetadataSource createMetadataSource(H http) { return new DefaultFilterInvocationSecurityMetadataSource( REGISTRY.createRequestMap());} UrlAuthorizationConfigurer 并不会检查 requestMap 是否为空，但是它会在 createRequestMap 方法中检查一下映射关系是否完整，例如下面这样： 123.antMatchers(&quot;/admin/**&quot;).access(&quot;ROLE_ADMIN&quot;).mvcMatchers(&quot;/user/**&quot;).access(&quot;ROLE_USER&quot;).antMatchers(&quot;/getinfo&quot;); 最后的 /getinfo 没有指定需要的权限，这种就是不完整，就会抛出异常。 ExpressionUrlAuthorizationConfigurer 会要求至少配置一个映射关系，UrlAuthorizationConfigurer 则无此要求。","link":"/2022/08/24/03-security-%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E6%9D%83%E9%99%90/"},{"title":"简易搭建 Security OAuth2 项目基于 password 模式","text":"简易搭建 Security OAuth2 项目基于 password 模式引入依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.security.oauth/spring-security-oauth2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;2.5.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 引入授权服务器1234567891011121314151617181920212223242526272829303132333435363738394041@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { @Autowired AuthenticationManager authenticationManager; @Autowired RedisConnectionFactory redisConnectionFactory; @Autowired UserDetailsService userDetailsService; @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(&quot;password&quot;) .authorizedGrantTypes(&quot;password&quot;,&quot;refresh_token&quot;) .accessTokenValiditySeconds(1800) .resourceIds(&quot;rid&quot;) .scopes(&quot;all&quot;) .secret(&quot;$2a$10$igDDIJWXnYW3ZT7w.DkLx.IU4KInjbtZMXK4gjYXyyrowcx.mKjpO&quot;); } @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.tokenStore(new RedisTokenStore(redisConnectionFactory)) .authenticationManager(authenticationManager) .userDetailsService(userDetailsService); } @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.allowFormAuthenticationForClients(); }} 引入资源服务器12345678910111213141516171819@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(&quot;rid&quot;) .stateless(true) //基于令牌认证 ; } @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests().antMatchers(&quot;/admin/**&quot;) .hasRole(&quot;admin&quot;) .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;) .anyRequest().authenticated(); }} 客户端搭建123456789101112131415161718192021222324252627282930313233343536@EnableWebSecurity@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Override @Bean protected AuthenticationManager authenticationManager() throws Exception { return super.authenticationManager(); } @Override @Bean protected UserDetailsService userDetailsService() { return super.userDetailsService(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(&quot;admin&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;) .and() .withUser(&quot;user&quot;).password(&quot;123&quot;).roles(&quot;user&quot;); } @Override protected void configure(HttpSecurity http) throws Exception { http.antMatcher(&quot;/oauth/**&quot;) .authorizeRequests() .antMatchers(&quot;/oauth/**&quot;) .permitAll() .and() .csrf().disable(); }} 测试首先在postman中发送 post 请求：http://localhost:8080/oauth/token获取到参数 需要携带的参数： client_id=password&amp;client_secret=123&amp;grant_type=password&amp;username=admin&amp;password=123&amp;scpoe=all client_id:客户端ID client_secret: 客户端密钥 grant_type:权限类型 username:用户名 password:密码 scope:范围 返回如下： 1234567{ &quot;access_token&quot;: &quot;aPmB0d6pK4ZKqnmQDEoWUqtww5M&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;zAgClPAjmXvjs6VA_DaDjuvMj2Y&quot;, &quot;expires_in&quot;: 1799, &quot;scope&quot;: &quot;all&quot;} 当我们需要访问资源的时候发送请求需要携带请求头： Authorization=Bearer aPmB0d6pK4ZKqnmQDEoWUqtww5M 这样就可以成功获取到资源 我们的 token 是有过期时间的，当我们需要刷新 token 的时候需要发送请求： 携带参数： 1client_id=password&amp;client_secret=123&amp;grant_type=refresh_token&amp;refresh_token=zAgClPAjmXvjs6VA_DaDjuvMj2Y&amp; client_id client_secret grant_type refresh_token 返回如下： 1234567{ &quot;access_token&quot;: &quot;tJjJfcmCwHx-vGPraXlwyPcsCz8&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;zAgClPAjmXvjs6VA_DaDjuvMj2Y&quot;, &quot;expires_in&quot;: 1799, &quot;scope&quot;: &quot;all&quot;} 这样就可以重新访问资源了。","link":"/2022/08/24/05-%E7%AE%80%E6%98%93%E6%90%AD%E5%BB%BA%20Security%20OAuth2%20%E9%A1%B9%E7%9B%AE%E5%9F%BA%E4%BA%8E%20password%20%E6%A8%A1%E5%BC%8F/"},{"title":"前后端分离中，使用 JSON进行登录","text":"服务端接口实现首先大家知道，用户登录的用户名/密码是在 UsernamePasswordAuthenticationFilter 类中处理的，具体的处理代码如下： 123456789101112public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { String username = obtainUsername(request); String password = obtainPassword(request); //省略}protected String obtainPassword(HttpServletRequest request) { return request.getParameter(passwordParameter);}protected String obtainUsername(HttpServletRequest request) { return request.getParameter(usernameParameter);} 从这段代码中，我们就可以看出来为什么 Spring Security 默认是通过 key/value 的形式来传递登录参数，因为它处理的方式就是 request.getParameter。 所以我们要定义成 JSON 的，思路很简单，就是自定义来定义一个过滤器代替 UsernamePasswordAuthenticationFilter ，然后在获取参数的时候，换一种方式就行了。 自定义过滤器接下来我们来自定义一个过滤器代替 UsernamePasswordAuthenticationFilter ，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example.security.json.config;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.http.MediaType;import org.springframework.security.authentication.AuthenticationServiceException;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;public class JsonFilter extends UsernamePasswordAuthenticationFilter { private static final Log log = LogFactory.getLog(JsonFilter.class); @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { if (!&quot;POST&quot;.equals(request.getMethod())) { throw new AuthenticationServiceException( &quot;Authentication method not supported: &quot; + request.getMethod()); } if (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)) { log.info(&quot;JSON登录&quot;); Map&lt;String, String&gt; loginData = new HashMap&lt;&gt;(); try { loginData = new ObjectMapper().readValue(request.getInputStream(), Map.class); } catch (IOException e) { } String username = loginData.get(getUsernameParameter()); String password = loginData.get(getPasswordParameter()); if (username == null) { username = &quot;&quot;; } if (password == null) { password = &quot;&quot;; } username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); } else { System.out.println(&quot;kv登录&quot;); return super.attemptAuthentication(request, response); } }} 这段逻辑我们基本上是模仿官方提供的 UsernamePasswordAuthenticationFilter 来写的，我来给大家稍微解释下： 首先登录请求肯定是 POST，如果不是 POST ，直接抛出异常，后面的也不处理了。 因为要在这里处理验证码，所以第二步从 session 中把已经下发过的验证码的值拿出来。 接下来通过 contentType 来判断当前请求是否通过 JSON 来传递参数，如果是通过 JSON 传递参数，则按照 JSON 的方式解析，如果不是，则调用 super.attemptAuthentication 方法，进入父类的处理逻辑中，也就是说，我们自定义的这个类，既支持 JSON 形式传递参数，也支持 key/value 形式传递参数。 如果是 JSON 形式的数据，我们就通过读取 request 中的 I/O 流，将 JSON 映射到一个 Map 上。 接下来从 Map 中取出 username 和 password，构造 UsernamePasswordAuthenticationToken 对象并作校验 过滤器定义完成后，接下来用我们自定义的过滤器代替默认的 UsernamePasswordAuthenticationFilter，首先我们需要提供一个 JsonFilter的实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.example.security.json.config;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.*;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.core.userdetails.User;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.AuthenticationFailureHandler;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Map;@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean JsonFilter jsonFilter() throws Exception { JsonFilter loginFilter = new JsonFilter(); loginFilter.setAuthenticationSuccessHandler(new AuthenticationSuccessHandler() { @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { response.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = response.getWriter(); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;message&quot;,&quot;登陆成功&quot;); map.put(&quot;data&quot;,authentication.getPrincipal());// map.put(&quot;data&quot;,principal); String s = new ObjectMapper().writeValueAsString(map); System.out.println(&quot;success=&gt;&quot;+s); out.write(s); out.flush(); out.close(); } }); loginFilter.setAuthenticationFailureHandler(new AuthenticationFailureHandler() { @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { response.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = response.getWriter(); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;error&quot;,exception.getMessage()); if (exception instanceof LockedException) { map.put(&quot;message&quot;,&quot;账户被锁定，请联系管理员!&quot;); } else if (exception instanceof CredentialsExpiredException) { map.put(&quot;message&quot;,&quot;密码过期，请联系管理员!&quot;); } else if (exception instanceof AccountExpiredException) { map.put(&quot;message&quot;,&quot;账户过期，请联系管理员!&quot;); } else if (exception instanceof BadCredentialsException) { map.put(&quot;message&quot;,&quot;用户名或者密码输入错误，请联系管理员!&quot;); } out.write(new ObjectMapper().writeValueAsString(map)); out.flush(); out.close(); } }); loginFilter.setAuthenticationManager(authenticationManagerBean()); loginFilter.setFilterProcessesUrl(&quot;/doLogin&quot;); return loginFilter; } @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(&quot;user&quot;).password(passwordEncoder().encode(&quot;123&quot;)).roles(&quot;user&quot;) .and() .withUser(&quot;admin&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;) .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;) .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); http.addFilterAt(jsonFilter(), UsernamePasswordAuthenticationFilter.class); }} 当我们代替了 UsernamePasswordAuthenticationFilter 之后，原本在 SecurityConfig#configure 方法中关于 form 表单的配置就会失效，那些失效的属性，都可以在配置 LoginFilter 实例的时候配置。 另外记得配置一个 AuthenticationManager，根据 WebSecurityConfigurerAdapter 中提供的配置即可。 FilterProcessUrl 则可以根据实际情况配置，如果不配置，默认的就是 /login。 最后，我们用自定义的 JsonFilter 实例代替 UsernamePasswordAuthenticationFilter，如下： 1234567@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... //省略 http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);} 调用 addFilterAt 方法完成替换操作。","link":"/2022/08/25/06-%E7%AE%80%E6%98%93%E6%90%AD%E5%BB%BA%20Security%20%E5%9F%BA%E4%BA%8E%20JSON%20%E7%99%BB%E5%BD%95/"},{"title":"Spring Security 自定义认证逻辑","text":"认证流程简析AuthenticationProvider 定义了 Spring Security 中的验证逻辑，我们来看下 AuthenticationProvider 的定义： 12345public interface AuthenticationProvider { Authentication authenticate(Authentication authentication) throws AuthenticationException; boolean supports(Class&lt;?&gt; authentication);} 可以看到，AuthenticationProvider 中就两个方法： authenticate 方法用来做验证，就是验证用户身份。 supports 则用来判断当前的 AuthenticationProvider 是否支持对应的 Authentication。 这里又涉及到一个东西，就是 Authentication。 玩过 Spring Security 的小伙伴都知道，在 Spring Security 中有一个非常重要的对象叫做 Authentication，我们可以在任何地方注入 Authentication 进而获取到当前登录用户信息，Authentication 本身是一个接口，它实际上对 java.security.Principal 做的进一步封装，我们来看下 Authentication 的定义： 12345678public interface Authentication extends Principal, Serializable { Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); Object getCredentials(); Object getDetails(); Object getPrincipal(); boolean isAuthenticated(); void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;} 可以看到，这里接口中的方法也没几个，我来大概解释下： getAuthorities 方法用来获取用户的权限。 getCredentials 方法用来获取用户凭证，一般来说就是密码。 getDetails 方法用来获取用户携带的详细信息，可能是当前请求之类的东西。 getPrincipal 方法用来获取当前用户，可能是一个用户名，也可能是一个用户对象。 isAuthenticated 当前用户是否认证成功。 Authentication 作为一个接口，它定义了用户，或者说 Principal 的一些基本行为，它有很多实现类。 在这些实现类中，我们最常用的就是 UsernamePasswordAuthenticationToken 了，而每一个 Authentication 都有适合它的 AuthenticationProvider 去处理校验。例如处理 UsernamePasswordAuthenticationToken 的 AuthenticationProvider 是 DaoAuthenticationProvider。 所以大家在 AuthenticationProvider 中看到一个 supports 方法，就是用来判断 AuthenticationProvider 是否支持当前 Authentication。 在一次完整的认证中，可能包含多个 AuthenticationProvider，而这多个 AuthenticationProvider 则由 ProviderManager 进行统一管理。 这里我们来重点看一下 DaoAuthenticationProvider，因为这是我们最常用的一个，当我们使用用户名/密码登录的时候，用的就是它，DaoAuthenticationProvider 的父类是 AbstractUserDetailsAuthenticationProvider，我们就先从它的父类看起： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class AbstractUserDetailsAuthenticationProvider implements AuthenticationProvider, InitializingBean, MessageSourceAware { public Authentication authenticate(Authentication authentication) throws AuthenticationException { String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot; : authentication.getName(); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) { cacheWasUsed = false; try { user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); } catch (UsernameNotFoundException notFound) { logger.debug(&quot;User '&quot; + username + &quot;' not found&quot;); if (hideUserNotFoundExceptions) { throw new BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } else { throw notFound; } } } try { preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); } catch (AuthenticationException exception) { if (cacheWasUsed) { cacheWasUsed = false; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); } else { throw exception; } } postAuthenticationChecks.check(user); if (!cacheWasUsed) { this.userCache.putUserInCache(user); } Object principalToReturn = user; if (forcePrincipalAsString) { principalToReturn = user.getUsername(); } return createSuccessAuthentication(principalToReturn, authentication, user); } public boolean supports(Class&lt;?&gt; authentication) { return (UsernamePasswordAuthenticationToken.class .isAssignableFrom(authentication)); }} AbstractUserDetailsAuthenticationProvider 的代码还是挺长的，这里我们重点关注两个方法：authenticate 和 supports。 authenticate 方法就是用来做认证的方法，我们来简单看下方法流程： 首先从 Authentication 提取出登录用户名。 然后通过拿着 username 去调用 retrieveUser 方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的 loadUserByUsername 方法，所以这里返回的 user 其实就是你的登录对象 接下来调用 preAuthenticationChecks.check 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等。 additionalAuthenticationChecks 方法则是做密码比对的，好多小伙伴好奇 Spring Security 的密码加密之后，是如何进行比较的，看这里就懂了，因为比较的逻辑很简单，我这里就不贴代码出来了。但是注意，additionalAuthenticationChecks 方法是一个抽象方法，具体的实现是在 AbstractUserDetailsAuthenticationProvider 的子类中实现的，也就是 DaoAuthenticationProvider。这个其实很好理解，因为 AbstractUserDetailsAuthenticationProvider 作为一个较通用的父类，处理一些通用的行为，我们在登录的时候，有的登录方式并不需要密码，所以 additionalAuthenticationChecks 方法一般交给它的子类去实现，在 DaoAuthenticationProvider 类中，additionalAuthenticationChecks 方法就是做密码比对的，在其他的 AuthenticationProvider 中，additionalAuthenticationChecks 方法的作用就不一定了。 最后在 postAuthenticationChecks.check 方法中检查密码是否过期。 接下来有一个 forcePrincipalAsString 属性，这个是是否强制将 Authentication 中的 principal 属性设置为字符串，这个属性我们一开始在 UsernamePasswordAuthenticationFilter 类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多。 最后，通过 createSuccessAuthentication 方法构建一个新的 UsernamePasswordAuthenticationToken。 supports 方法就比较简单了，主要用来判断当前的 Authentication 是否是 UsernamePasswordAuthenticationToken。 由于 AbstractUserDetailsAuthenticationProvider 已经把 authenticate 和 supports 方法实现了，所以在 DaoAuthenticationProvider 中，我们主要关注 additionalAuthenticationChecks 方法即可： 123456789101112131415161718public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider { @SuppressWarnings(&quot;deprecation&quot;) protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { if (authentication.getCredentials() == null) { throw new BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } String presentedPassword = authentication.getCredentials().toString(); if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) { throw new BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } }} 大家可以看到，additionalAuthenticationChecks 方法主要用来做密码比对的，逻辑也比较简单，就是调用 PasswordEncoder 的 matches 方法做比对，如果密码不对则直接抛出异常即可。 正常情况下，我们使用用户名/密码登录，最终都会走到这一步。 而 AuthenticationProvider 都是通过 ProviderManager#authenticate 方法来调用的。由于我们的一次认证可能会存在多个 AuthenticationProvider，所以，在 ProviderManager#authenticate 方法中会逐个遍历 AuthenticationProvider，并调用他们的 authenticate 方法做认证，我们来稍微瞅一眼 ProviderManager#authenticate 方法： 123456789101112public Authentication authenticate(Authentication authentication) throws AuthenticationException { for (AuthenticationProvider provider : getProviders()) { result = provider.authenticate(authentication); if (result != null) { copyDetails(authentication, result); break; } } ... ...} 可以看到，在这个方法中，会遍历所有的 AuthenticationProvider，并调用它的 authenticate 方法进行认证。 好了，大致的认证流程说完之后，相信大家已经明白了我们要从哪里下手了。 自定义认证思路之前我们通过自定义过滤器，将自定义的过滤器加入到 Spring Security 过滤器链中，进而实现了添加登录验证码功能，但是我们也说这种方式是有弊端的，就是破坏了原有的过滤器链，请求每次都要走一遍验证码过滤器，这样不合理。 登录请求是调用 AbstractUserDetailsAuthenticationProvider#authenticate 方法进行认证的，在该方法中，又会调用到 DaoAuthenticationProvider#additionalAuthenticationChecks 方法做进一步的校验，去校验用户登录密码。我们可以自定义一个 AuthenticationProvider 代替 DaoAuthenticationProvider，并重写它里边的 additionalAuthenticationChecks 方法，在重写的过程中，加入验证码的校验逻辑即可。 这样既不破坏原有的过滤器链，又实现了自定义认证功能。常见的手机号码动态登录，也可以使用这种方式来认证。 代码实现首先我们需要验证码，如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt; 然后我们提供一个实体类用来描述验证码的基本信息： 123456789101112@BeanProducer verifyCode() { Properties properties = new Properties(); properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;150&quot;); properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;50&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;0123456789&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;); Config config = new Config(properties); DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); defaultKaptcha.setConfig(config); return defaultKaptcha;} 这段配置很简单，我们就是提供了验证码图片的宽高、字符库以及生成的验证码字符长度。 接下来提供一个返回验证码图片的接口： 123456789101112131415@RestControllerpublic class VerifyCodeController { @Autowired Producer producer; @GetMapping(&quot;/vc.jpg&quot;) public void getVerifyCode(HttpServletResponse resp, HttpSession session) throws IOException { resp.setContentType(&quot;image/jpeg&quot;); String text = producer.createText(); session.setAttribute(&quot;verify_code&quot;, text); BufferedImage image = producer.createImage(text); try(ServletOutputStream out = resp.getOutputStream()) { ImageIO.write(image, &quot;jpg&quot;, out); } }} 这里我们生成验证码图片，并将生成的验证码字符存入 HttpSession 中。注意这里我用到了 try-with-resources 。 接下来我们来自定义一个 MyAuthenticationProvider 继承自 DaoAuthenticationProvider，并重写 additionalAuthenticationChecks 方法： 12345678910111213public class MyAuthenticationProvider extends DaoAuthenticationProvider { @Override protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { HttpServletRequest req = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); String code = req.getParameter(&quot;code&quot;); String verify_code = (String) req.getSession().getAttribute(&quot;verify_code&quot;); if (code == null || verify_code == null || !code.equals(verify_code)) { throw new AuthenticationServiceException(&quot;验证码错误&quot;); } super.additionalAuthenticationChecks(userDetails, authentication); }} 在 additionalAuthenticationChecks 方法中： 首先获取当前请求，注意这种获取方式，在基于 Spring 的 web 项目中，我们可以随时随地获取到当前请求，获取方式就是我上面给出的代码。 从当前请求中拿到 code 参数，也就是用户传来的验证码。 从 session 中获取生成的验证码字符串。 两者进行比较，如果验证码输入错误，则直接抛出异常。 最后通过 super 调用父类方法，也就是 DaoAuthenticationProvider 的 additionalAuthenticationChecks 方法，该方法中主要做密码的校验。 MyAuthenticationProvider 定义好之后，接下来主要是如何让 MyAuthenticationProvider 代替 DaoAuthenticationProvider。 前面我们说，所有的 AuthenticationProvider 都是放在 ProviderManager 中统一管理的，所以接下来我们就要自己提供 ProviderManager，然后注入自定义的 MyAuthenticationProvider，这一切操作都在 SecurityConfig 中完成： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Bean MyAuthenticationProvider myAuthenticationProvider() { MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider(); myAuthenticationProvider.setPasswordEncoder(passwordEncoder()); myAuthenticationProvider.setUserDetailsService(userDetailsService()); return myAuthenticationProvider; } @Override @Bean protected AuthenticationManager authenticationManager() throws Exception { ProviderManager manager = new ProviderManager(Arrays.asList(myAuthenticationProvider())); return manager; } @Bean @Override protected UserDetailsService userDetailsService() { InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withUsername(&quot;admin&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build()); return manager; } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&quot;/vc.jpg&quot;).permitAll() .anyRequest().authenticated() .and() .formLogin() .successHandler((req, resp, auth) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(RespBean.ok(&quot;success&quot;, auth.getPrincipal()))); out.flush(); out.close(); }) .failureHandler((req, resp, e) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(RespBean.error(e.getMessage()))); out.flush(); out.close(); }) .permitAll() .and() .csrf().disable(); }} 这里的代码我稍作解释： 我们需要提供一个 MyAuthenticationProvider 的实例，创建该实例时，需要提供 UserDetailService 和 PasswordEncoder 实例。 通过重写 authenticationManager 方法来提供一个自己的 AuthenticationManager，实际上就是 ProviderManager，在创建 ProviderManager 时，加入自己的 myAuthenticationProvider。 这里为了简单，我将用户直接存在内存中，提供一个 UserDetailsService 实例即可。 最后就简单配置一下各种回调即可，另外记得设置 /vc.jpg 任何人都能访问。 好了，如此之后，在不需要修改原生过滤器链的情况下，我们嵌入了自己的认证逻辑。 测试首先通过 postman 发送获取验证码请求：http://localhost:8080/vc.jpg 成功获取到验证码，在发送登陆请求的时候携带验证码，返回如下： 12345678910111213141516{ &quot;data&quot;: { &quot;password&quot;: null, &quot;username&quot;: &quot;admin&quot;, &quot;authorities&quot;: [ { &quot;authority&quot;: &quot;ROLE_admin&quot; } ], &quot;accountNonExpired&quot;: true, &quot;accountNonLocked&quot;: true, &quot;credentialsNonExpired&quot;: true, &quot;enabled&quot;: true }, &quot;mes&quot;: &quot;success&quot;}","link":"/2022/08/25/09-%E7%AE%80%E6%98%93%E6%90%AD%E5%BB%BA%20Security%20%E5%9F%BA%E4%BA%8E%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%A4%E8%AF%81%E9%80%BB%E8%BE%91%20%E7%99%BB%E5%BD%95/"},{"title":"","text":"title: Spring Security 中使用 JWTcategories: spring-securitydate: ‘2022-08-25 11:17:01’tags: spring-security 在前后端分离的项目中，登录策略也有不少，不过 JWT 算是目前比较流行的一种解决方案 1 无状态登录1.1 什么是有状态？有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如Tomcat中的Session。例如登录：用户登录后，我们把用户的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session，然后下次请求，用户携带cookie值来（这一步有浏览器自动完成），我们就能识别到对应session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下： 服务端保存大量数据，增加服务端压力 服务端保存用户状态，不支持集群化部署 1.2 什么是无状态微服务集群中的每个服务，对外提供的都使用RESTful风格的接口。而RESTful风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 那么这种无状态性有哪些好处呢？ 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署） 减小服务端存储压力 1.3.如何实现无状态无状态登录的流程： 首先客户端发送账户名/密码到服务端进行认证 认证通过后，服务端将用户信息加密并且编码成一个token，返回给客户端 以后客户端每次发送请求，都需要携带认证的token 服务端对客户端发送来的token进行解密，判断是否有效，并且获取用户登录信息 1.4 JWT1.4.1 简介JWT，全称是Json Web Token， 是一种JSON风格的轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权： JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的Java 实现是GitHub 上的开源项目 jjwt，地址如下：https://github.com/jwtk/jjwt 1.4.2 JWT数据格式JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 加密算法，自定义 我们会对头部进行Base64Url编码（可解码），得到第一部分数据。 Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息： iss (issuer)：表示签发人 exp (expiration time)：表示token过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 这部分也会采用Base64Url编码，得到第二部分数据。 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过Header中配置的加密算法生成。用于验证整个数据完整和可靠性。 1.4.3 JWT交互流程 应用程序或客户端向授权服务器请求授权 获取到授权后，授权服务器会向应用程序返回访问令牌 应用程序使用访问令牌来访问受保护资源（如API） 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了RESTful的无状态规范。 1.5 JWT 存在的问题说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下： 续签问题，这是被很多人诟病的问题之一，传统的cookie+session的方案天然的支持续签，但是jwt由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入redis，虽然可以解决问题，但是jwt也变得不伦不类了。 注销问题，由于服务端不再保存用户信息，所以一般可以通过修改secret来实现注销，服务端secret修改后，已经颁发的未过期的token就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。 密码重置，密码重置后，原本的token依然可以访问系统，这时候也需要强制修改secret。 基于第2点和第3点，一般建议不同用户取不同secret。 2 实战2.1 环境搭建首先我们来创建一个Spring Boot项目，创建时需要添加Spring Security依赖，创建完成后，添加 jjwt 依赖，完整的pom.xml文件如下： 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; 然后在项目中创建一个简单的 User 对象实现 UserDetails 接口，如下： 12345678910111213141516171819202122232425public class User implements UserDetails { private String username; private String password; private List&lt;GrantedAuthority&gt; authorities; public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; } //省略getter/setter} 这个就是我们的用户对象，先放着备用，再创建一个HelloController，内容如下： 1234567891011@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;hello jwt !&quot;; } @GetMapping(&quot;/admin&quot;) public String admin() { return &quot;hello admin !&quot;; }} HelloController 很简单，这里有两个接口，设计是 /hello 接口可以被具有 user 角色的用户访问，而 /admin 接口则可以被具有 admin 角色的用户访问。 2.2 JWT 过滤器配置接下来提供两个和 JWT 相关的过滤器配置： 一个是用户登录的过滤器，在用户的登录的过滤器中校验用户是否登录成功，如果登录成功，则生成一个token返回给客户端，登录失败则给前端一个登录失败的提示。 第二个过滤器则是当其他请求发送来，校验token的过滤器，如果校验成功，就让请求继续执行。 这两个过滤器，我们分别来看，先看第一个： 1234567891011121314151617181920212223242526272829303132333435363738public class JwtLoginFilter extends AbstractAuthenticationProcessingFilter { protected JwtLoginFilter(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager) { super(new AntPathRequestMatcher(defaultFilterProcessesUrl)); setAuthenticationManager(authenticationManager); } @Override public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse resp) throws AuthenticationException, IOException, ServletException { User user = new ObjectMapper().readValue(req.getInputStream(), User.class); return getAuthenticationManager().authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword())); } @Override protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse resp, FilterChain chain, Authentication authResult) throws IOException, ServletException { Collection&lt;? extends GrantedAuthority&gt; authorities = authResult.getAuthorities(); StringBuffer as = new StringBuffer(); for (GrantedAuthority authority : authorities) { as.append(authority.getAuthority()) .append(&quot;,&quot;); } String jwt = Jwts.builder() .claim(&quot;authorities&quot;, as)//配置用户角色 .setSubject(authResult.getName()) .setExpiration(new Date(System.currentTimeMillis() + 10 * 60 * 1000)) .signWith(SignatureAlgorithm.HS512,&quot;sang@123&quot;) .compact(); resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(jwt)); out.flush(); out.close(); } protected void unsuccessfulAuthentication(HttpServletRequest req, HttpServletResponse resp, AuthenticationException failed) throws IOException, ServletException { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;登录失败!&quot;); out.flush(); out.close(); }} 关于这个类，我说如下几点： 自定义 JwtLoginFilter 继承自 AbstractAuthenticationProcessingFilter，并实现其中的三个默认方法。 attemptAuthentication方法中，我们从登录参数中提取出用户名密码，然后调用AuthenticationManager.authenticate()方法去进行自动校验。 第二步如果校验成功，就会来到successfulAuthentication回调中，在successfulAuthentication方法中，将用户角色遍历然后用一个 , 连接起来，然后再利用Jwts去生成token，按照代码的顺序，生成过程一共配置了四个参数，分别是用户角色、主题、过期时间以及加密算法和密钥，然后将生成的token写出到客户端。 第二步如果校验失败就会来到unsuccessfulAuthentication方法中，在这个方法中返回一个错误提示给客户端即可。 再来看第二个token校验的过滤器： 123456789101112131415public class JwtFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) servletRequest; String jwtToken = req.getHeader(&quot;authorization&quot;); System.out.println(jwtToken); Claims claims = Jwts.parser().setSigningKey(&quot;sang@123&quot;).parseClaimsJws(jwtToken.replace(&quot;Bearer&quot;,&quot;&quot;)) .getBody(); String username = claims.getSubject();//获取当前登录用户名 List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(&quot;authorities&quot;)); UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(username, null, authorities); SecurityContextHolder.getContext().setAuthentication(token); filterChain.doFilter(req,servletResponse); }} 关于这个过滤器，我说如下几点： 首先从请求头中提取出 authorization 字段，这个字段对应的value就是用户的token。 将提取出来的token字符串转换为一个Claims对象，再从Claims对象中提取出当前用户名和用户角色，创建一个UsernamePasswordAuthenticationToken放到当前的Context中，然后执行过滤链使请求继续执行下去。 如此之后，两个和JWT相关的过滤器就算配置好了。 2.3 Spring Security 配置接下来我们来配置 Spring Security,如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.wenx.security.jwt.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.HttpMethod;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.password.NoOpPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication().withUser(&quot;admin&quot;) .password(&quot;123&quot;).roles(&quot;admin&quot;) .and() .withUser(&quot;user&quot;) .password(&quot;123&quot;) .roles(&quot;user&quot;); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&quot;/hello&quot;).hasRole(&quot;user&quot;) .antMatchers(&quot;/admin&quot;).hasRole(&quot;admin&quot;) .antMatchers(HttpMethod.POST, &quot;/login&quot;).permitAll() .anyRequest().authenticated() .and() .addFilterBefore(new JwtLoginFilter(&quot;/login&quot;,authenticationManager()), UsernamePasswordAuthenticationFilter.class) .addFilterBefore(new JwtFilter(),UsernamePasswordAuthenticationFilter.class) .csrf().disable(); }} 简单起见，这里我并未对密码进行加密，因此配置了NoOpPasswordEncoder的实例。 简单起见，这里并未连接数据库，我直接在内存中配置了两个用户，两个用户具备不同的角色。 配置路径规则时， /hello 接口必须要具备 user 角色才能访问， /admin 接口必须要具备 admin 角色才能访问，POST 请求并且是 /login 接口则可以直接通过，其他接口必须认证后才能访问。 最后配置上两个自定义的过滤器并且关闭掉csrf保护。 2.4 测试做完这些之后，我们的环境就算完全搭建起来了，接下来启动项目然后在 POSTMAN 中进行测试 发送 http://localhost:8080/login[POST请求] 携带参数{&quot;username&quot;:&quot;user&quot;,&quot;password&quot;:&quot;123&quot;} 会返回 token 信息 发送请求资源的请求： http://localhost:8080/user/hello 携带请求头：Authorization=Bearer XXX.XXX.XXX 可以成功获取到资源。","link":"/2022/11/21/07-%E7%AE%80%E6%98%93%E6%90%AD%E5%BB%BA%20Security%20%E5%9F%BA%E4%BA%8E%20JWT%20%E7%99%BB%E5%BD%95/"},{"title":"Spring Security 自定义认证逻辑基础上保存用户详细信息","text":"1. AuthenticationAuthentication 接口用来保存我们的登录用户信息，实际上，它是对主体（java.security.Principal）做了进一步的封装。 我们来看下 Authentication 的一个定义： 12345678public interface Authentication extends Principal, Serializable { Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); Object getCredentials(); Object getDetails(); Object getPrincipal(); boolean isAuthenticated(); void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;} 接口的解释如下： getAuthorities 方法用来获取用户的权限。 getCredentials 方法用来获取用户凭证，一般来说就是密码。 getDetails 方法用来获取用户携带的详细信息，可能是当前请求之类的东西。 getPrincipal 方法用来获取当前用户，可能是一个用户名，也可能是一个用户对象。 isAuthenticated 当前用户是否认证成功。 这里有一个比较好玩的方法，叫做 getDetails。关于这个方法，源码的解释如下： Stores additional details about the authentication request. These might be an IP address, certificate serial number etc. 从这段解释中，我们可以看出，该方法实际上就是用来存储有关身份认证的其他信息的，例如 IP 地址、证书信息等等。 实际上，在默认情况下，这里存储的就是用户登录的 IP 地址和 sessionId。我们从源码角度来看下。 2. 源码分析松哥的 SpringSecurity 系列已经写到第 12 篇了，看了前面的文章，相信大家已经明白用户登录必经的一个过滤器就是 UsernamePasswordAuthenticationFilter，在该类的 attemptAuthentication 方法中，对请求参数做提取，在 attemptAuthentication 方法中，会调用到一个方法，就是 setDetails。 我们一起来看下 setDetails 方法： 1234protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request));} UsernamePasswordAuthenticationToken 是 Authentication 的具体实现，所以这里实际上就是在设置 details，至于 details 的值，则是通过 authenticationDetailsSource 来构建的，我们来看下： 1234567891011121314151617public class WebAuthenticationDetailsSource implements AuthenticationDetailsSource&lt;HttpServletRequest, WebAuthenticationDetails&gt; { public WebAuthenticationDetails buildDetails(HttpServletRequest context) { return new WebAuthenticationDetails(context); }}public class WebAuthenticationDetails implements Serializable { private final String remoteAddress; private final String sessionId; public WebAuthenticationDetails(HttpServletRequest request) { this.remoteAddress = request.getRemoteAddr(); HttpSession session = request.getSession(false); this.sessionId = (session != null) ? session.getId() : null; } //省略其他方法} 默认通过 WebAuthenticationDetailsSource 来构建 WebAuthenticationDetails，并将结果设置到 Authentication 的 details 属性中去。而 WebAuthenticationDetails 中定义的属性，大家看一下基本上就明白，这就是保存了用户登录地址和 sessionId。 那么看到这里，大家基本上就明白了，用户登录的 IP 地址实际上我们可以直接从 WebAuthenticationDetails 中获取到。 我举一个简单例子，例如我们登录成功后，可以通过如下方式随时随地拿到用户 IP： 12345678@Servicepublic class HelloService { public void hello() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); WebAuthenticationDetails details = (WebAuthenticationDetails) authentication.getDetails(); System.out.println(details); }} 这个获取过程之所以放在 service 来做，就是为了演示随时随地这个特性。然后我们在 controller 中调用该方法，当访问接口时，可以看到如下日志： 1WebAuthenticationDetails@fffc7f0c: RemoteIpAddress: 127.0.0.1; SessionId: 303C7F254DF8B86667A2B20AA0667160 可以看到，用户的 IP 地址和 SessionId 都给出来了。这两个属性在 WebAuthenticationDetails 中都有对应的 get 方法，也可以单独获取属性值。 3. 定制当然，WebAuthenticationDetails 也可以自己定制，因为默认它只提供了 IP 和 sessionid 两个信息，如果我们想保存关于 Http 请求的更多信息，就可以通过自定义 WebAuthenticationDetails 来实现。 如果我们要定制 WebAuthenticationDetails，还要连同 WebAuthenticationDetailsSource 一起重新定义。 12345678910111213public class MyAuthenticationProvider extends DaoAuthenticationProvider { @Override protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { HttpServletRequest req = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); String code = req.getParameter(&quot;code&quot;); String verify_code = (String) req.getSession().getAttribute(&quot;verify_code&quot;); if (code == null || verify_code == null || !code.equals(verify_code)) { throw new AuthenticationServiceException(&quot;验证码错误&quot;); } super.additionalAuthenticationChecks(userDetails, authentication); }} 不过这个验证操作，我们也可以放在自定义的 WebAuthenticationDetails 中来做，我们定义如下两个类： 123456789101112131415161718192021222324public class MyWebAuthenticationDetails extends WebAuthenticationDetails { private boolean isPassed; public MyWebAuthenticationDetails(HttpServletRequest req) { super(req); String code = req.getParameter(&quot;code&quot;); String verify_code = (String) req.getSession().getAttribute(&quot;verify_code&quot;); if (code != null &amp;&amp; verify_code != null &amp;&amp; code.equals(verify_code)) { isPassed = true; } } public boolean isPassed() { return isPassed; }}@Componentpublic class MyWebAuthenticationDetailsSource implements AuthenticationDetailsSource&lt;HttpServletRequest,MyWebAuthenticationDetails&gt; { @Override public MyWebAuthenticationDetails buildDetails(HttpServletRequest context) { return new MyWebAuthenticationDetails(context); }} 首先我们定义 MyWebAuthenticationDetails，由于它的构造方法中，刚好就提供了 HttpServletRequest 对象，所以我们可以直接利用该对象进行验证码判断，并将判断结果交给 isPassed 变量保存。如果我们想扩展属性，只需要在 MyWebAuthenticationDetails 中再去定义更多属性，然后从 HttpServletRequest 中提取出来设置给对应的属性即可，这样，在登录成功后就可以随时随地获取这些属性了。 最后在 MyWebAuthenticationDetailsSource 中构造 MyWebAuthenticationDetails 并返回。 定义完成后，接下来，我们就可以直接在 MyAuthenticationProvider 中进行调用了： 12345678910public class MyAuthenticationProvider extends DaoAuthenticationProvider { @Override protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { if (!((MyWebAuthenticationDetails) authentication.getDetails()).isPassed()) { throw new AuthenticationServiceException(&quot;验证码错误&quot;); } super.additionalAuthenticationChecks(userDetails, authentication); }} 直接从 authentication 中获取到 details 并调用 isPassed 方法，有问题就抛出异常即可。 最后的问题就是如何用自定义的 MyWebAuthenticationDetailsSource 代替系统默认的 WebAuthenticationDetailsSource，很简单，我们只需要在 SecurityConfig 中稍作定义即可： 1234567891011@AutowiredMyWebAuthenticationDetailsSource myWebAuthenticationDetailsSource;@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... .and() .formLogin() .authenticationDetailsSource(myWebAuthenticationDetailsSource) ...} 将 MyWebAuthenticationDetailsSource 注入到 SecurityConfig 中，并在 formLogin 中配置 authenticationDetailsSource 即可成功使用我们自定义的 WebAuthenticationDetails。 这样自定义完成后，WebAuthenticationDetails 中原有的功能依然保留，也就是我们还可以利用老办法继续获取用户 IP 以及 sessionId 等信息，如下： 12345678@Servicepublic class HelloService { public void hello() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); MyWebAuthenticationDetails details = (MyWebAuthenticationDetails) authentication.getDetails(); System.out.println(details); }} 这里类型强转的时候，转为 MyWebAuthenticationDetails 即可。","link":"/2022/08/25/10-Security%20%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/"},{"title":"Spring Boot + Spring Security 实现自动登录","text":"实现自动登录功能自动登录是我们在软件开发时一个非常常见的功能 很多网站我们在登录的时候都会看到类似的选项，毕竟总让用户输入用户名密码是一件很麻烦的事。 自动登录功能就是，用户在登录成功后，在某一段时间内，如果用户关闭了浏览器并重新打开，或者服务器重启了，都不需要用户重新登录了，用户依然可以直接访问接口数据。 实例代码首先，要实现记住我这个功能，其实只需要其实只需要在 Spring Security 的配置中，添加如下代码即可： 12345678910111213141516171819@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .rememberMe() .and() .csrf().disable();}@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(&quot;user&quot;).password(passwordEncoder().encode(&quot;123&quot;)).roles(&quot;user&quot;) ;} 大家看到，这里只需要添加一个 .rememberMe() 即可，自动登录功能就成功添加进来了。 接下来我们随意添加一个测试接口： 1234567@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;hello&quot;; }} 重启项目，我们访问 hello 接口，此时会自动跳转到登录页面 这个时候大家发现，默认的登录页面多了一个选项，就是记住我。我们输入用户名密码，并且勾选上记住我这个框，然后点击登录按钮执行登录操作 可以看到，登录数据中，除了 username 和 password 之外，还有一个 remember-me，之所以给大家看这个，是想告诉大家，如果你你需要自定义登录页面，RememberMe 这个选项的 key 该怎么写。 登录成功之后，就会自动跳转到 hello 接口了。我们注意，系统访问 hello 接口的时候，携带的 cookie 接下来，我们关闭浏览器，再重新打开浏览器。正常情况下，浏览器关闭再重新打开，如果需要再次访问 hello 接口，就需要我们重新登录了。但是此时，我们再去访问 hello 接口，发现不用重新登录了，直接就能访问到，这就说明我们的 RememberMe 配置生效了（即下次自动登录功能生效了） 原理分析按理说，浏览器关闭再重新打开，就要重新登录，现在竟然不用等了，那么这个功能到底是怎么实现的呢？ 首先我们来分析一下 cookie 中多出来的这个 remember-me，这个值一看就是一个 Base64 转码后的字符串，我们可以使用网上的一些在线工具来解码，可以自己简单写两行代码来解码： 12345@Testvoid contextLoads() throws UnsupportedEncodingException { String s = new String(Base64.getDecoder().decode(&quot;amF2YWJveToxNTg5MTA0MDU1MzczOjI1NzhmZmJjMjY0ODVjNTM0YTJlZjkyOWFjMmVmYzQ3&quot;), &quot;UTF-8&quot;); System.out.println(&quot;s = &quot; + s);} 执行这段代码，输出结果如下： 1s = user:1589104055373:2578ffbc26485c534a2ef929ac2efc47 可以看到，这段 Base64 字符串实际上用 : 隔开，分成了三部分： 第一段是用户名，这个无需质疑。 第二段看起来是一个时间戳，我们通过在线工具或者 Java 代码解析后发现，这是一个两周后的数据。 第三段,这是使用 MD5 散列函数算出来的值，他的明文格式是 username + &quot;:&quot; + tokenExpiryTime + &quot;:&quot; + password + &quot;:&quot; + key，最后的 key 是一个散列盐值，可以用来防治令牌被修改。 了解到 cookie 中 remember-me 的含义之后，那么我们对于记住我的登录流程也就很容易猜到了了。 在浏览器关闭后，并重新打开之后，用户再去访问 hello 接口，此时会携带着 cookie 中的 remember-me 到服务端，服务到拿到值之后，可以方便的计算出用户名和过期时间，再根据用户名查询到用户密码，然后通过 MD5 散列函数计算出散列值，再将计算出的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效。 流程就是这么个流程，接下来我们通过分析源码来验证一下这个流程对不对。 源码分析接下来，我们通过源码来验证一下我们上面说的对不对。 这里主要从两个方面来介绍，一个是 remember-me 这个令牌生成的过程，另一个则是它解析的过程。 生成生成的核心处理方法在：TokenBasedRememberMeServices#onLoginSuccess： 1234567891011121314151617181920212223@Overridepublic void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = retrieveUserName(successfulAuthentication); String password = retrievePassword(successfulAuthentication); if (!StringUtils.hasLength(password)) { UserDetails user = getUserDetailsService().loadUserByUsername(username); password = user.getPassword(); } int tokenLifetime = calculateLoginLifetime(request, successfulAuthentication); long expiryTime = System.currentTimeMillis(); expiryTime += 1000L * (tokenLifetime &lt; 0 ? TWO_WEEKS_S : tokenLifetime); String signatureValue = makeTokenSignature(expiryTime, username, password); setCookie(new String[] { username, Long.toString(expiryTime), signatureValue }, tokenLifetime, request, response);}protected String makeTokenSignature(long tokenExpiryTime, String username, String password) { String data = username + &quot;:&quot; + tokenExpiryTime + &quot;:&quot; + password + &quot;:&quot; + getKey(); MessageDigest digest; digest = MessageDigest.getInstance(&quot;MD5&quot;); return new String(Hex.encode(digest.digest(data.getBytes())));} 这段方法的逻辑其实很好理解： 首先从登录成功的 Authentication 中提取出用户名/密码。 由于登录成功之后，密码可能被擦除了，所以，如果一开始没有拿到密码，就再从 UserDetailsService 中重新加载用户并重新获取密码。 再接下来去获取令牌的有效期，令牌有效期默认就是两周。 再接下来调用 makeTokenSignature 方法去计算散列值，实际上就是根据 username、令牌有效期以及 password、key 一起计算一个散列值。如果我们没有自己去设置这个 key，默认是在 RememberMeConfigurer#getKey 方法中进行设置的，它的值是一个 UUID 字符串。 最后，将用户名、令牌有效期以及计算得到的散列值放入 Cookie 中。 由于我们自己没有设置 key，key 默认值是一个 UUID 字符串，这样会带来一个问题，就是如果服务端重启，这个 key 会变，这样就导致之前派发出去的所有 remember-me 自动登录令牌失效，所以，我们可以指定这个 key。指定方式如下： 123456789101112@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .key(&quot;javaboy&quot;) .and() .csrf().disable();} 如果自己配置了 key，即使服务端重启，即使浏览器打开再关闭，也依然能够访问到 hello 接口。 这是 remember-me 令牌生成的过程。 AbstractAuthenticationProcessingFilter#doFilter -&gt; AbstractAuthenticationProcessingFilter#successfulAuthentication -&gt; AbstractRememberMeServices#loginSuccess -&gt; TokenBasedRememberMeServices#onLoginSuccess。 解析那么当用户关掉并打开浏览器之后，重新访问 /hello 接口，此时的认证流程又是怎么样的呢？ 我们之前说过，Spring Security 中的一系列功能都是通过一个过滤器链实现的，RememberMe 这个功能当然也不例外。 Spring Security 中提供了 RememberMeAuthenticationFilter 类专门用来做相关的事情，我们来看下 RememberMeAuthenticationFilter 的 doFilter 方法： 1234567891011121314151617181920212223242526272829public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; if (SecurityContextHolder.getContext().getAuthentication() == null) { Authentication rememberMeAuth = rememberMeServices.autoLogin(request, response); if (rememberMeAuth != null) { rememberMeAuth = authenticationManager.authenticate(rememberMeAuth); SecurityContextHolder.getContext().setAuthentication(rememberMeAuth); onSuccessfulAuthentication(request, response, rememberMeAuth); if (this.eventPublisher != null) { eventPublisher .publishEvent(new InteractiveAuthenticationSuccessEvent( SecurityContextHolder.getContext() .getAuthentication(), this.getClass())); } if (successHandler != null) { successHandler.onAuthenticationSuccess(request, response, rememberMeAuth); return; } } chain.doFilter(request, response); } else { chain.doFilter(request, response); }} 可以看到，就是在这里实现的。 这个方法最关键的地方在于，如果从 SecurityContextHolder 中无法获取到当前登录用户实例，那么就调用 rememberMeServices.autoLogin 逻辑进行登录，我们来看下这个方法： 123456789101112131415161718192021222324252627public final Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) { String rememberMeCookie = extractRememberMeCookie(request); if (rememberMeCookie == null) { return null; } logger.debug(&quot;Remember-me cookie detected&quot;); if (rememberMeCookie.length() == 0) { logger.debug(&quot;Cookie was empty&quot;); cancelCookie(request, response); return null; } UserDetails user = null; try { String[] cookieTokens = decodeCookie(rememberMeCookie); user = processAutoLoginCookie(cookieTokens, request, response); userDetailsChecker.check(user); logger.debug(&quot;Remember-me cookie accepted&quot;); return createSuccessfulAuthentication(request, user); } catch (CookieTheftException cte) { throw cte; } cancelCookie(request, response); return null;} 可以看到，这里就是提取出 cookie 信息，并对 cookie 信息进行解码，解码之后，再调用 processAutoLoginCookie 方法去做校验，processAutoLoginCookie 方法的代码我就不贴了，核心流程就是首先获取用户名和过期时间，再根据用户名查询到用户密码，然后通过 MD5 散列函数计算出散列值，再将拿到的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效，进而确认登录是否有效。 总结看了上面的文章，大家可能已经发现，如果我们开启了 RememberMe 功能，最最核心的东西就是放在 cookie 中的令牌了，这个令牌突破了 session 的限制，即使服务器重启、即使浏览器关闭又重新打开，只要这个令牌没有过期，就能访问到数据。 一旦令牌丢失，别人就可以拿着这个令牌随意登录我们的系统了，这是一个非常危险的操作。 但是实际上这是一段悖论，为了提高用户体验（少登录），我们的系统不可避免的引出了一些安全问题，不过我们可以通过技术将安全风险降低到最小。 RememberMe 持久化方案在实际应用中，我们肯定要把这些安全风险降到最低。降低安全风险，主要有两个方面： 持久化方案 二次校验 持久化令牌原理要理解持久化令牌，一定要先搞明白自动登录的基本玩法 持久化令牌就是在基本的自动登录功能基础上，又增加了新的校验参数，来提高系统的安全性，这一些都是由开发者在后台完成的，对于用户来说，登录体验和普通的自动登录体验是一样的。 在持久化令牌中，新增了两个经过 MD5 散列函数计算的校验参数，一个是 series，另一个是 token。其中，series 只有当用户在使用用户名/密码登录时，才会生成或者更新，而 token 只要有新的会话，就会重新生成，这样就可以避免一个用户同时在多端登录，就像手机 QQ ，一个手机上登录了，就会踢掉另外一个手机的登录，这样用户就会很容易发现账户是否泄漏 持久化令牌的具体处理类在 PersistentTokenBasedRememberMeServices 中，自动化登录具体的处理类是在 TokenBasedRememberMeServices 中，它们有一个共同的父类 而用来保存令牌的处理类则是 PersistentRememberMeToken，该类的定义也很简洁命令： 1234567public class PersistentRememberMeToken { private final String username; private final String series; private final String tokenValue; private final Date date; //省略 getter} 这里的 Date 表示上一次使用自动登录的时间。 代码实例首先我们需要一张表来记录令牌信息，这张表我们可以完全自定义，也可以使用系统默认提供的 JDBC 来操作，如果使用默认的 JDBC，即 JdbcTokenRepositoryImpl，我们可以来分析一下该类的定义： 123456789public class JdbcTokenRepositoryImpl extends JdbcDaoSupport implements PersistentTokenRepository { public static final String CREATE_TABLE_SQL = &quot;create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, &quot; + &quot;token varchar(64) not null, last_used timestamp not null)&quot;; public static final String DEF_TOKEN_BY_SERIES_SQL = &quot;select username,series,token,last_used from persistent_logins where series = ?&quot;; public static final String DEF_INSERT_TOKEN_SQL = &quot;insert into persistent_logins (username, series, token, last_used) values(?,?,?,?)&quot;; public static final String DEF_UPDATE_TOKEN_SQL = &quot;update persistent_logins set token = ?, last_used = ? where series = ?&quot;; public static final String DEF_REMOVE_USER_TOKENS_SQL = &quot;delete from persistent_logins where username = ?&quot;;} 根据这段 SQL 定义，我们就可以分析出来表的结构 1234567CREATE TABLE `persistent_logins` ( `username` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL, `series` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL, `token` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL, `last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`series`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; 首先我们在数据库中准备好这张表。 既然要连接数据库，我们还需要准备 jdbc 和 mysql 依赖，如下： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 然后修改 application.properties ，配置数据库连接信息： 123spring.datasource.url=jdbc:mysql:///oauth2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=123 接下来，我们修改 SecurityConfig，如下： 1234567891011121314151617181920212223@AutowiredDataSource dataSource;@BeanJdbcTokenRepositoryImpl jdbcTokenRepository() { JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); return jdbcTokenRepository;}@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .key(&quot;wenx&quot;) .tokenRepository(jdbcTokenRepository()) .and() .csrf().disable();} 提供一个 JdbcTokenRepositoryImpl 实例，并给其配置 DataSource 数据源，最后通过 tokenRepository 将 JdbcTokenRepositoryImpl 实例纳入配置中。 OK，做完这一切，我们就可以测试了。 测试我们还是先去访问 /hello 接口，此时会自动跳转到登录页面，然后我们执行登录操作，记得勾选上“记住我”这个选项，登录成功后，我们可以重启服务器、然后关闭浏览器再打开，再去访问 /hello 接口，发现依然能够访问到，说明我们的持久化令牌配置已经生效。 令牌经过解析之后，格式如下： 1emhqATk3ZDBdR8862WP4Ig%3D%3D:ZAEv6EIWqA7CkGbYewCh8g%3D%3D 这其中，%3D 表示 =，所以上面的字符实际上可以翻译成下面这样： 1emhqATk3ZDBdR8862WP4Ig==:ZAEv6EIWqA7CkGbYewCh8g== 此时，查看数据库，我们发现之前的表中生成了一条记录 数据库中的记录和我们看到的 remember-me 令牌解析后是一致的。 源码分析这次的实现类主要是：PersistentTokenBasedRememberMeServices，我们先来看里边几个和令牌生成相关的方法： 1234567891011121314151617181920212223protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = successfulAuthentication.getName(); PersistentRememberMeToken persistentToken = new PersistentRememberMeToken( username, generateSeriesData(), generateTokenData(), new Date()); tokenRepository.createNewToken(persistentToken); addCookie(persistentToken, request, response);}protected String generateSeriesData() { byte[] newSeries = new byte[seriesLength]; random.nextBytes(newSeries); return new String(Base64.getEncoder().encode(newSeries));}protected String generateTokenData() { byte[] newToken = new byte[tokenLength]; random.nextBytes(newToken); return new String(Base64.getEncoder().encode(newToken));}private void addCookie(PersistentRememberMeToken token, HttpServletRequest request, HttpServletResponse response) { setCookie(new String[] { token.getSeries(), token.getTokenValue() }, getTokenValiditySeconds(), request, response);} 可以看到： 在登录成功后，首先还是获取到用户名，即 username。 接下来构造一个 PersistentRememberMeToken 实例，generateSeriesData 和 generateTokenData 方法分别用来获取 series 和 token，具体的生成过程实际上就是调用 SecureRandom 生成随机数再进行 Base64 编码，不同于我们以前用的 Math.random 或者 java.util.Random 这种伪随机数，SecureRandom 则采用的是类似于密码学的随机数生成规则，其输出结果较难预测，适合在登录这样的场景下使用。 调用 tokenRepository 实例中的 createNewToken 方法，tokenRepository 实际上就是我们一开始配置的 JdbcTokenRepositoryImpl，所以这行代码实际上就是将 PersistentRememberMeToken 存入数据库中。 最后 addCookie，大家可以看到，就是添加了 series 和 token。 这是令牌生成的过程，还有令牌校验的过程，也在该类中，方法是：processAutoLoginCookie： 123456789101112131415161718192021222324protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) { final String presentedSeries = cookieTokens[0]; final String presentedToken = cookieTokens[1]; PersistentRememberMeToken token = tokenRepository .getTokenForSeries(presentedSeries); if (!presentedToken.equals(token.getTokenValue())) { tokenRepository.removeUserTokens(token.getUsername()); throw new CookieTheftException( messages.getMessage( &quot;PersistentTokenBasedRememberMeServices.cookieStolen&quot;, &quot;Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.&quot;)); } if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L &lt; System .currentTimeMillis()) { throw new RememberMeAuthenticationException(&quot;Remember-me login has expired&quot;); } PersistentRememberMeToken newToken = new PersistentRememberMeToken( token.getUsername(), token.getSeries(), generateTokenData(), new Date()); tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); addCookie(newToken, request, response); return getUserDetailsService().loadUserByUsername(token.getUsername());} 这段逻辑也比较简单： 首先从前端传来的 cookie 中解析出 series 和 token。 根据 series 从数据库中查询出一个 PersistentRememberMeToken 实例。 如果查出来的 token 和前端传来的 token 不相同，说明账号可能被人盗用（别人用你的令牌登录之后，token 会变）。此时根据用户名移除相关的 token，相当于必须要重新输入用户名密码登录才能获取新的自动登录权限。 接下来校验 token 是否过期。 构造新的 PersistentRememberMeToken 对象，并且更新数据库中的 token（这就是我们文章开头说的，新的会话都会对应一个新的 token）。 将新的令牌重新添加到 cookie 中返回。 根据用户名查询用户信息，再走一波登录流程 二次校验持久化令牌的方式其实已经安全很多了，但是依然存在用户身份被盗用的问题，这个问题实际上很难完美解决，我们能做的，只能是当发生用户身份被盗用这样的事情时，将损失降低到最小。 因此，我们来看下另一种方案，就是二次校验。 为了让用户使用方便，我们开通了自动登录功能，但是自动登录功能又带来了安全风险，一个规避的办法就是如果用户使用了自动登录功能，我们可以只让他做一些常规的不敏感操作，例如数据浏览、查看，但是不允许他做任何修改、删除操作，如果用户点击了修改、删除按钮，我们可以跳转回登录页面，让用户重新输入密码确认身份，然后再允许他执行敏感操作。 这个功能在 Shiro 中有一个比较方便的过滤器可以配置，Spring Security 当然也一样，例如我现在提供三个访问接口： 123456789101112131415@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;hello&quot;; } @GetMapping(&quot;/admin&quot;) public String admin() { return &quot;admin&quot;; } @GetMapping(&quot;/rememberme&quot;) public String rememberme() { return &quot;rememberme&quot;; }} 第一个 /hello 接口，只要认证后就可以访问，无论是通过用户名密码认证还是通过自动登录认证，只要认证了，就可以访问。 第二个 /admin 接口，必须要用户名密码认证之后才能访问，如果用户是通过自动登录认证的，则必须重新输入用户名密码才能访问该接口。 第三个 /rememberme 接口，必须是通过自动登录认证后才能访问，如果用户是通过用户名/密码认证的，则无法访问该接口。 123456789101112131415@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&quot;/rememberme&quot;).rememberMe() .antMatchers(&quot;/admin&quot;).fullyAuthenticated() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .key(&quot;wenx&quot;) .tokenRepository(jdbcTokenRepository()) .and() .csrf().disable();} 可以看到： /rememberme 接口是需要 rememberMe 才能访问。 /admin 是需要 fullyAuthenticated，fullyAuthenticated 不同于 authenticated，fullyAuthenticated 不包含自动登录的形式，而 authenticated 包含自动登录的形式。 最后剩余的接口（/hello）都是 authenticated 就能访问。","link":"/2022/08/25/08-%E7%AE%80%E6%98%93%E6%90%AD%E5%BB%BA%20Security%20%E5%9F%BA%E4%BA%8E%20RememberMe%20%E7%99%BB%E5%BD%95/"},{"title":"Spring Security 自动踢掉前一个登录用户","text":"1.需求分析在同一个系统中，我们可能只允许一个用户在一个终端上登录，一般来说这可能是出于安全方面的考虑，但是也有一些情况是出于业务上的考虑，松哥之前遇到的需求就是业务原因要求一个用户只能在一个设备上登录。 要实现一个用户不可以同时在两台设备上登录，我们有两种思路： 后来的登录自动踢掉前面的登录，就像大家在扣扣中看到的效果。 如果用户已经登录，则不允许后来者登录。 这种思路都能实现这个功能，具体使用哪一个，还要看我们具体的需求。 在 Spring Security 中，这两种都很好实现，一个配置就可以搞定。 2.具体实现2.1 踢掉已经登录用户想要用新的登录踢掉旧的登录，我们只需要将最大会话数设置为 1 即可，配置如下： 12345678910111213@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login.html&quot;) .permitAll() .and() .csrf().disable() .sessionManagement() .maximumSessions(1);} maximumSessions 表示配置最大会话数为 1，这样后面的登录就会自动踢掉前面的登录。这里其他的配置都是我们前面文章讲过的，我就不再重复介绍，文末可以下载案例完整代码。 配置完成后，分别用 Chrome 和 Firefox 两个浏览器进行测试（或者使用 Chrome 中的多用户功能）。 Chrome 上登录成功后，访问 /hello 接口。 Firefox 上登录成功后，访问 /hello 接口。 在 Chrome 上再次访问 /hello 接口，此时会看到如下提示： 1This session has been expired (possibly due to multiple concurrent logins being attempted as the same user). 可以看到，这里说这个 session 已经过期，原因则是由于使用同一个用户进行并发登录。 2.2 禁止新的登录如果相同的用户已经登录了，你不想踢掉他，而是想禁止新的登录操作，那也好办，配置方式如下： 1234567891011121314@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login.html&quot;) .permitAll() .and() .csrf().disable() .sessionManagement() .maximumSessions(1) .maxSessionsPreventsLogin(true);} 我们还需要再提供一个 Bean： 1234@BeanHttpSessionEventPublisher httpSessionEventPublisher() { return new HttpSessionEventPublisher();} 为什么要加这个 Bean 呢？因为在 Spring Security 中，它是通过监听 session 的销毁事件，来及时的清理 session 的记录。用户从不同的浏览器登录后，都会有对应的 session，当用户注销登录之后，session 就会失效，但是默认的失效是通过调用 StandardSession#invalidate 方法来实现的，这一个失效事件无法被 Spring 容器感知到，进而导致当用户注销登录之后，Spring Security 没有及时清理会话信息表，以为用户还在线，进而导致用户无法重新登录进来（小伙伴们可以自行尝试不添加上面的 Bean，然后让用户注销登录之后再重新登录）。 为了解决这一问题，我们提供一个 HttpSessionEventPublisher ，这个类实现了 HttpSessionListener 接口，在该 Bean 中，可以将 session 创建以及销毁的事件及时感知到，并且调用 Spring 中的事件机制将相关的创建和销毁事件发布出去，进而被 Spring Security 感知到，该类部分源码如下： 12345678public void sessionCreated(HttpSessionEvent event) { HttpSessionCreatedEvent e = new HttpSessionCreatedEvent(event.getSession()); getContext(event.getSession().getServletContext()).publishEvent(e);}public void sessionDestroyed(HttpSessionEvent event) { HttpSessionDestroyedEvent e = new HttpSessionDestroyedEvent(event.getSession()); getContext(event.getSession().getServletContext()).publishEvent(e);} 3.实现原理首先我们知道，在用户登录的过程中，会经过 UsernamePasswordAuthenticationFilter，而 UsernamePasswordAuthenticationFilter 中过滤方法的调用是在 AbstractAuthenticationProcessingFilter 中触发的，我们来看下 AbstractAuthenticationProcessingFilter#doFilter 方法的调用： 1234567891011121314151617181920212223242526272829public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; if (!requiresAuthentication(request, response)) { chain.doFilter(request, response); return; } Authentication authResult; try { authResult = attemptAuthentication(request, response); if (authResult == null) { return; } sessionStrategy.onAuthentication(authResult, request, response); } catch (InternalAuthenticationServiceException failed) { unsuccessfulAuthentication(request, response, failed); return; } catch (AuthenticationException failed) { unsuccessfulAuthentication(request, response, failed); return; } // Authentication success if (continueChainBeforeSuccessfulAuthentication) { chain.doFilter(request, response); } successfulAuthentication(request, response, chain, authResult); 在这段代码中，我们可以看到，调用 attemptAuthentication 方法走完认证流程之后，回来之后，接下来就是调用 sessionStrategy.onAuthentication 方法，这个方法就是用来处理 session 的并发问题的。具体在： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ConcurrentSessionControlAuthenticationStrategy implements MessageSourceAware, SessionAuthenticationStrategy { public void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) { final List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions( authentication.getPrincipal(), false); int sessionCount = sessions.size(); int allowedSessions = getMaximumSessionsForThisUser(authentication); if (sessionCount &lt; allowedSessions) { // They haven't got too many login sessions running at present return; } if (allowedSessions == -1) { // We permit unlimited logins return; } if (sessionCount == allowedSessions) { HttpSession session = request.getSession(false); if (session != null) { // Only permit it though if this request is associated with one of the // already registered sessions for (SessionInformation si : sessions) { if (si.getSessionId().equals(session.getId())) { return; } } } // If the session is null, a new one will be created by the parent class, // exceeding the allowed number } allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry); } protected void allowableSessionsExceeded(List&lt;SessionInformation&gt; sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException { if (exceptionIfMaximumExceeded || (sessions == null)) { throw new SessionAuthenticationException(messages.getMessage( &quot;ConcurrentSessionControlAuthenticationStrategy.exceededAllowed&quot;, new Object[] {allowableSessions}, &quot;Maximum sessions of {0} for this principal exceeded&quot;)); } // Determine least recently used sessions, and mark them for invalidation sessions.sort(Comparator.comparing(SessionInformation::getLastRequest)); int maximumSessionsExceededBy = sessions.size() - allowableSessions + 1; List&lt;SessionInformation&gt; sessionsToBeExpired = sessions.subList(0, maximumSessionsExceededBy); for (SessionInformation session: sessionsToBeExpired) { session.expireNow(); } }} 首先调用 sessionRegistry.getAllSessions 方法获取当前用户的所有 session，该方法在调用时，传递两个参数，一个是当前用户的 authentication，另一个参数 false 表示不包含已经过期的 session（在用户登录成功后，会将用户的 sessionid 存起来，其中 key 是用户的主体（principal），value 则是该主题对应的 sessionid 组成的一个集合）。 接下来计算出当前用户已经有几个有效 session 了，同时获取允许的 session 并发数。 如果当前 session 数（sessionCount）小于 session 并发数（allowedSessions），则不做任何处理；如果 allowedSessions 的值为 -1，表示对 session 数量不做任何限制。 如果当前 session 数（sessionCount）等于 session 并发数（allowedSessions），那就先看看当前 session 是否不为 null，并且已经存在于 sessions 中了，如果已经存在了，那都是自家人，不做任何处理；如果当前 session 为 null，那么意味着将有一个新的 session 被创建出来，届时当前 session 数（sessionCount）就会超过 session 并发数（allowedSessions）。 如果前面的代码中都没能 return 掉，那么将进入策略判断方法 allowableSessionsExceeded 中。 allowableSessionsExceeded 方法中，首先会有 exceptionIfMaximumExceeded 属性，这就是我们在 SecurityConfig 中配置的 maxSessionsPreventsLogin 的值，默认为 false，如果为 true，就直接抛出异常，那么这次登录就失败了（对应 2.2 小节的效果），如果为 false，则对 sessions 按照请求时间进行排序，然后再使多余的 session 过期即可","link":"/2022/08/25/11-Spring%20Security%20%E8%87%AA%E5%8A%A8%E8%B8%A2%E6%8E%89%E5%89%8D%E4%B8%80%E4%B8%AA%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/11/21/hello-world/"}],"tags":[{"name":"spring-boot spring-security","slug":"spring-boot-spring-security","link":"/tags/spring-boot-spring-security/"},{"name":"spring-security","slug":"spring-security","link":"/tags/spring-security/"}],"categories":[{"name":"spring-boot spring-security","slug":"spring-boot-spring-security","link":"/categories/spring-boot-spring-security/"},{"name":"spring-boot spring-security OAuth2","slug":"spring-boot-spring-security-OAuth2","link":"/categories/spring-boot-spring-security-OAuth2/"},{"name":"spring-security","slug":"spring-security","link":"/categories/spring-security/"}],"pages":[]}